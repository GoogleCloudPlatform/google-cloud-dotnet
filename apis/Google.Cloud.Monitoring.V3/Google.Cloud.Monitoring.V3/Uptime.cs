// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: google/monitoring/v3/uptime.proto
// </auto-generated>
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace Google.Cloud.Monitoring.V3 {

  /// <summary>Holder for reflection information generated from google/monitoring/v3/uptime.proto</summary>
  public static partial class UptimeReflection {

    #region Descriptor
    /// <summary>File descriptor for google/monitoring/v3/uptime.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static UptimeReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "CiFnb29nbGUvbW9uaXRvcmluZy92My91cHRpbWUucHJvdG8SFGdvb2dsZS5t",
            "b25pdG9yaW5nLnYzGiNnb29nbGUvYXBpL21vbml0b3JlZF9yZXNvdXJjZS5w",
            "cm90bxoeZ29vZ2xlL3Byb3RvYnVmL2R1cmF0aW9uLnByb3RvInIKD0ludGVy",
            "bmFsQ2hlY2tlchISCgpwcm9qZWN0X2lkGAEgASgJEg8KB25ldHdvcmsYAiAB",
            "KAkSEAoIZ2NwX3pvbmUYAyABKAkSEgoKY2hlY2tlcl9pZBgEIAEoCRIUCgxk",
            "aXNwbGF5X25hbWUYBSABKAkiwQkKEVVwdGltZUNoZWNrQ29uZmlnEgwKBG5h",
            "bWUYASABKAkSFAoMZGlzcGxheV9uYW1lGAIgASgJEjsKEm1vbml0b3JlZF9y",
            "ZXNvdXJjZRgDIAEoCzIdLmdvb2dsZS5hcGkuTW9uaXRvcmVkUmVzb3VyY2VI",
            "ABJPCg5yZXNvdXJjZV9ncm91cBgEIAEoCzI1Lmdvb2dsZS5tb25pdG9yaW5n",
            "LnYzLlVwdGltZUNoZWNrQ29uZmlnLlJlc291cmNlR3JvdXBIABJHCgpodHRw",
            "X2NoZWNrGAUgASgLMjEuZ29vZ2xlLm1vbml0b3JpbmcudjMuVXB0aW1lQ2hl",
            "Y2tDb25maWcuSHR0cENoZWNrSAESRQoJdGNwX2NoZWNrGAYgASgLMjAuZ29v",
            "Z2xlLm1vbml0b3JpbmcudjMuVXB0aW1lQ2hlY2tDb25maWcuVGNwQ2hlY2tI",
            "ARIpCgZwZXJpb2QYByABKAsyGS5nb29nbGUucHJvdG9idWYuRHVyYXRpb24S",
            "KgoHdGltZW91dBgIIAEoCzIZLmdvb2dsZS5wcm90b2J1Zi5EdXJhdGlvbhJQ",
            "ChBjb250ZW50X21hdGNoZXJzGAkgAygLMjYuZ29vZ2xlLm1vbml0b3Jpbmcu",
            "djMuVXB0aW1lQ2hlY2tDb25maWcuQ29udGVudE1hdGNoZXISQQoQc2VsZWN0",
            "ZWRfcmVnaW9ucxgKIAMoDjInLmdvb2dsZS5tb25pdG9yaW5nLnYzLlVwdGlt",
            "ZUNoZWNrUmVnaW9uEhMKC2lzX2ludGVybmFsGA8gASgIEkAKEWludGVybmFs",
            "X2NoZWNrZXJzGA4gAygLMiUuZ29vZ2xlLm1vbml0b3JpbmcudjMuSW50ZXJu",
            "YWxDaGVja2VyGmEKDVJlc291cmNlR3JvdXASEAoIZ3JvdXBfaWQYASABKAkS",
            "PgoNcmVzb3VyY2VfdHlwZRgCIAEoDjInLmdvb2dsZS5tb25pdG9yaW5nLnYz",
            "Lkdyb3VwUmVzb3VyY2VUeXBlGuQCCglIdHRwQ2hlY2sSDwoHdXNlX3NzbBgB",
            "IAEoCBIMCgRwYXRoGAIgASgJEgwKBHBvcnQYAyABKAUSWAoJYXV0aF9pbmZv",
            "GAQgASgLMkUuZ29vZ2xlLm1vbml0b3JpbmcudjMuVXB0aW1lQ2hlY2tDb25m",
            "aWcuSHR0cENoZWNrLkJhc2ljQXV0aGVudGljYXRpb24SFAoMbWFza19oZWFk",
            "ZXJzGAUgASgIEk8KB2hlYWRlcnMYBiADKAsyPi5nb29nbGUubW9uaXRvcmlu",
            "Zy52My5VcHRpbWVDaGVja0NvbmZpZy5IdHRwQ2hlY2suSGVhZGVyc0VudHJ5",
            "GjkKE0Jhc2ljQXV0aGVudGljYXRpb24SEAoIdXNlcm5hbWUYASABKAkSEAoI",
            "cGFzc3dvcmQYAiABKAkaLgoMSGVhZGVyc0VudHJ5EgsKA2tleRgBIAEoCRIN",
            "CgV2YWx1ZRgCIAEoCToCOAEaGAoIVGNwQ2hlY2sSDAoEcG9ydBgBIAEoBRoh",
            "Cg5Db250ZW50TWF0Y2hlchIPCgdjb250ZW50GAEgASgJQgoKCHJlc291cmNl",
            "QhQKEmNoZWNrX3JlcXVlc3RfdHlwZSJuCg1VcHRpbWVDaGVja0lwEjcKBnJl",
            "Z2lvbhgBIAEoDjInLmdvb2dsZS5tb25pdG9yaW5nLnYzLlVwdGltZUNoZWNr",
            "UmVnaW9uEhAKCGxvY2F0aW9uGAIgASgJEhIKCmlwX2FkZHJlc3MYAyABKAkq",
            "ZQoRVXB0aW1lQ2hlY2tSZWdpb24SFgoSUkVHSU9OX1VOU1BFQ0lGSUVEEAAS",
            "BwoDVVNBEAESCgoGRVVST1BFEAISEQoNU09VVEhfQU1FUklDQRADEhAKDEFT",
            "SUFfUEFDSUZJQxAEKlsKEUdyb3VwUmVzb3VyY2VUeXBlEh0KGVJFU09VUkNF",
            "X1RZUEVfVU5TUEVDSUZJRUQQABIMCghJTlNUQU5DRRABEhkKFUFXU19FTEJf",
            "TE9BRF9CQUxBTkNFUhACQqMBChhjb20uZ29vZ2xlLm1vbml0b3JpbmcudjNC",
            "C1VwdGltZVByb3RvUAFaPmdvb2dsZS5nb2xhbmcub3JnL2dlbnByb3RvL2dv",
            "b2dsZWFwaXMvbW9uaXRvcmluZy92Mzttb25pdG9yaW5nqgIaR29vZ2xlLkNs",
            "b3VkLk1vbml0b3JpbmcuVjPKAhpHb29nbGVcQ2xvdWRcTW9uaXRvcmluZ1xW",
            "M2IGcHJvdG8z"));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { global::Google.Api.MonitoredResourceReflection.Descriptor, global::Google.Protobuf.WellKnownTypes.DurationReflection.Descriptor, },
          new pbr::GeneratedClrTypeInfo(new[] {typeof(global::Google.Cloud.Monitoring.V3.UptimeCheckRegion), typeof(global::Google.Cloud.Monitoring.V3.GroupResourceType), }, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Cloud.Monitoring.V3.InternalChecker), global::Google.Cloud.Monitoring.V3.InternalChecker.Parser, new[]{ "ProjectId", "Network", "GcpZone", "CheckerId", "DisplayName" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Cloud.Monitoring.V3.UptimeCheckConfig), global::Google.Cloud.Monitoring.V3.UptimeCheckConfig.Parser, new[]{ "Name", "DisplayName", "MonitoredResource", "ResourceGroup", "HttpCheck", "TcpCheck", "Period", "Timeout", "ContentMatchers", "SelectedRegions", "IsInternal", "InternalCheckers" }, new[]{ "Resource", "CheckRequestType" }, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Google.Cloud.Monitoring.V3.UptimeCheckConfig.Types.ResourceGroup), global::Google.Cloud.Monitoring.V3.UptimeCheckConfig.Types.ResourceGroup.Parser, new[]{ "GroupId", "ResourceType" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Cloud.Monitoring.V3.UptimeCheckConfig.Types.HttpCheck), global::Google.Cloud.Monitoring.V3.UptimeCheckConfig.Types.HttpCheck.Parser, new[]{ "UseSsl", "Path", "Port", "AuthInfo", "MaskHeaders", "Headers" }, null, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Google.Cloud.Monitoring.V3.UptimeCheckConfig.Types.HttpCheck.Types.BasicAuthentication), global::Google.Cloud.Monitoring.V3.UptimeCheckConfig.Types.HttpCheck.Types.BasicAuthentication.Parser, new[]{ "Username", "Password" }, null, null, null),
            null, }),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Cloud.Monitoring.V3.UptimeCheckConfig.Types.TcpCheck), global::Google.Cloud.Monitoring.V3.UptimeCheckConfig.Types.TcpCheck.Parser, new[]{ "Port" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Cloud.Monitoring.V3.UptimeCheckConfig.Types.ContentMatcher), global::Google.Cloud.Monitoring.V3.UptimeCheckConfig.Types.ContentMatcher.Parser, new[]{ "Content" }, null, null, null)}),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Cloud.Monitoring.V3.UptimeCheckIp), global::Google.Cloud.Monitoring.V3.UptimeCheckIp.Parser, new[]{ "Region", "Location", "IpAddress" }, null, null, null)
          }));
    }
    #endregion

  }
  #region Enums
  /// <summary>
  /// The regions from which an uptime check can be run.
  /// </summary>
  public enum UptimeCheckRegion {
    /// <summary>
    /// Default value if no region is specified. Will result in uptime checks
    /// running from all regions.
    /// </summary>
    [pbr::OriginalName("REGION_UNSPECIFIED")] RegionUnspecified = 0,
    /// <summary>
    /// Allows checks to run from locations within the United States of America.
    /// </summary>
    [pbr::OriginalName("USA")] Usa = 1,
    /// <summary>
    /// Allows checks to run from locations within the continent of Europe.
    /// </summary>
    [pbr::OriginalName("EUROPE")] Europe = 2,
    /// <summary>
    /// Allows checks to run from locations within the continent of South
    /// America.
    /// </summary>
    [pbr::OriginalName("SOUTH_AMERICA")] SouthAmerica = 3,
    /// <summary>
    /// Allows checks to run from locations within the Asia Pacific area (ex:
    /// Singapore).
    /// </summary>
    [pbr::OriginalName("ASIA_PACIFIC")] AsiaPacific = 4,
  }

  /// <summary>
  /// The supported resource types that can be used as values of
  /// `group_resource.resource_type`.
  /// `INSTANCE` includes `gce_instance` and `aws_ec2_instance` resource types.
  /// The resource types `gae_app` and `uptime_url` are not valid here because
  /// group checks on App Engine modules and URLs are not allowed.
  /// </summary>
  public enum GroupResourceType {
    /// <summary>
    /// Default value (not valid).
    /// </summary>
    [pbr::OriginalName("RESOURCE_TYPE_UNSPECIFIED")] ResourceTypeUnspecified = 0,
    /// <summary>
    /// A group of instances from Google Cloud Platform (GCP) or
    /// Amazon Web Services (AWS).
    /// </summary>
    [pbr::OriginalName("INSTANCE")] Instance = 1,
    /// <summary>
    /// A group of Amazon ELB load balancers.
    /// </summary>
    [pbr::OriginalName("AWS_ELB_LOAD_BALANCER")] AwsElbLoadBalancer = 2,
  }

  #endregion

  #region Messages
  /// <summary>
  /// Nimbus InternalCheckers.
  /// </summary>
  public sealed partial class InternalChecker : pb::IMessage<InternalChecker> {
    private static readonly pb::MessageParser<InternalChecker> _parser = new pb::MessageParser<InternalChecker>(() => new InternalChecker());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<InternalChecker> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Cloud.Monitoring.V3.UptimeReflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public InternalChecker() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public InternalChecker(InternalChecker other) : this() {
      projectId_ = other.projectId_;
      network_ = other.network_;
      gcpZone_ = other.gcpZone_;
      checkerId_ = other.checkerId_;
      displayName_ = other.displayName_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public InternalChecker Clone() {
      return new InternalChecker(this);
    }

    /// <summary>Field number for the "project_id" field.</summary>
    public const int ProjectIdFieldNumber = 1;
    private string projectId_ = "";
    /// <summary>
    /// The GCP project ID. Not necessarily the same as the project_id for the
    /// config.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string ProjectId {
      get { return projectId_; }
      set {
        projectId_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "network" field.</summary>
    public const int NetworkFieldNumber = 2;
    private string network_ = "";
    /// <summary>
    /// The internal network to perform this uptime check on.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Network {
      get { return network_; }
      set {
        network_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "gcp_zone" field.</summary>
    public const int GcpZoneFieldNumber = 3;
    private string gcpZone_ = "";
    /// <summary>
    /// The GCP zone the uptime check should egress from. Only respected for
    /// internal uptime checks, where internal_network is specified.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string GcpZone {
      get { return gcpZone_; }
      set {
        gcpZone_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "checker_id" field.</summary>
    public const int CheckerIdFieldNumber = 4;
    private string checkerId_ = "";
    /// <summary>
    /// The checker ID.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string CheckerId {
      get { return checkerId_; }
      set {
        checkerId_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "display_name" field.</summary>
    public const int DisplayNameFieldNumber = 5;
    private string displayName_ = "";
    /// <summary>
    /// The checker's human-readable name.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string DisplayName {
      get { return displayName_; }
      set {
        displayName_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as InternalChecker);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(InternalChecker other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (ProjectId != other.ProjectId) return false;
      if (Network != other.Network) return false;
      if (GcpZone != other.GcpZone) return false;
      if (CheckerId != other.CheckerId) return false;
      if (DisplayName != other.DisplayName) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (ProjectId.Length != 0) hash ^= ProjectId.GetHashCode();
      if (Network.Length != 0) hash ^= Network.GetHashCode();
      if (GcpZone.Length != 0) hash ^= GcpZone.GetHashCode();
      if (CheckerId.Length != 0) hash ^= CheckerId.GetHashCode();
      if (DisplayName.Length != 0) hash ^= DisplayName.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (ProjectId.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(ProjectId);
      }
      if (Network.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(Network);
      }
      if (GcpZone.Length != 0) {
        output.WriteRawTag(26);
        output.WriteString(GcpZone);
      }
      if (CheckerId.Length != 0) {
        output.WriteRawTag(34);
        output.WriteString(CheckerId);
      }
      if (DisplayName.Length != 0) {
        output.WriteRawTag(42);
        output.WriteString(DisplayName);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (ProjectId.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(ProjectId);
      }
      if (Network.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Network);
      }
      if (GcpZone.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(GcpZone);
      }
      if (CheckerId.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(CheckerId);
      }
      if (DisplayName.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(DisplayName);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(InternalChecker other) {
      if (other == null) {
        return;
      }
      if (other.ProjectId.Length != 0) {
        ProjectId = other.ProjectId;
      }
      if (other.Network.Length != 0) {
        Network = other.Network;
      }
      if (other.GcpZone.Length != 0) {
        GcpZone = other.GcpZone;
      }
      if (other.CheckerId.Length != 0) {
        CheckerId = other.CheckerId;
      }
      if (other.DisplayName.Length != 0) {
        DisplayName = other.DisplayName;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            ProjectId = input.ReadString();
            break;
          }
          case 18: {
            Network = input.ReadString();
            break;
          }
          case 26: {
            GcpZone = input.ReadString();
            break;
          }
          case 34: {
            CheckerId = input.ReadString();
            break;
          }
          case 42: {
            DisplayName = input.ReadString();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// This message configures which resources and services to monitor for
  /// availability.
  /// </summary>
  public sealed partial class UptimeCheckConfig : pb::IMessage<UptimeCheckConfig> {
    private static readonly pb::MessageParser<UptimeCheckConfig> _parser = new pb::MessageParser<UptimeCheckConfig>(() => new UptimeCheckConfig());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<UptimeCheckConfig> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Cloud.Monitoring.V3.UptimeReflection.Descriptor.MessageTypes[1]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public UptimeCheckConfig() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public UptimeCheckConfig(UptimeCheckConfig other) : this() {
      name_ = other.name_;
      displayName_ = other.displayName_;
      period_ = other.period_ != null ? other.period_.Clone() : null;
      timeout_ = other.timeout_ != null ? other.timeout_.Clone() : null;
      contentMatchers_ = other.contentMatchers_.Clone();
      selectedRegions_ = other.selectedRegions_.Clone();
      isInternal_ = other.isInternal_;
      internalCheckers_ = other.internalCheckers_.Clone();
      switch (other.ResourceCase) {
        case ResourceOneofCase.MonitoredResource:
          MonitoredResource = other.MonitoredResource.Clone();
          break;
        case ResourceOneofCase.ResourceGroup:
          ResourceGroup = other.ResourceGroup.Clone();
          break;
      }

      switch (other.CheckRequestTypeCase) {
        case CheckRequestTypeOneofCase.HttpCheck:
          HttpCheck = other.HttpCheck.Clone();
          break;
        case CheckRequestTypeOneofCase.TcpCheck:
          TcpCheck = other.TcpCheck.Clone();
          break;
      }

      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public UptimeCheckConfig Clone() {
      return new UptimeCheckConfig(this);
    }

    /// <summary>Field number for the "name" field.</summary>
    public const int NameFieldNumber = 1;
    private string name_ = "";
    /// <summary>
    /// A unique resource name for this UptimeCheckConfig. The format is:
    ///
    ///   `projects/[PROJECT_ID]/uptimeCheckConfigs/[UPTIME_CHECK_ID]`.
    ///
    /// This field should be omitted when creating the uptime check configuration;
    /// on create, the resource name is assigned by the server and included in the
    /// response.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Name {
      get { return name_; }
      set {
        name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "display_name" field.</summary>
    public const int DisplayNameFieldNumber = 2;
    private string displayName_ = "";
    /// <summary>
    /// A human-friendly name for the uptime check configuration. The display name
    /// should be unique within a Stackdriver Account in order to make it easier
    /// to identify; however, uniqueness is not enforced. Required.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string DisplayName {
      get { return displayName_; }
      set {
        displayName_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "monitored_resource" field.</summary>
    public const int MonitoredResourceFieldNumber = 3;
    /// <summary>
    /// The [monitored
    /// resource](https://cloud.google.com/monitoring/api/resources) associated
    /// with the configuration.
    /// The following monitored resource types are supported for uptime checks:
    ///   uptime_url
    ///   gce_instance
    ///   gae_app
    ///   aws_ec2_instance
    ///   aws_elb_load_balancer
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Api.MonitoredResource MonitoredResource {
      get { return resourceCase_ == ResourceOneofCase.MonitoredResource ? (global::Google.Api.MonitoredResource) resource_ : null; }
      set {
        resource_ = value;
        resourceCase_ = value == null ? ResourceOneofCase.None : ResourceOneofCase.MonitoredResource;
      }
    }

    /// <summary>Field number for the "resource_group" field.</summary>
    public const int ResourceGroupFieldNumber = 4;
    /// <summary>
    /// The group resource associated with the configuration.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Cloud.Monitoring.V3.UptimeCheckConfig.Types.ResourceGroup ResourceGroup {
      get { return resourceCase_ == ResourceOneofCase.ResourceGroup ? (global::Google.Cloud.Monitoring.V3.UptimeCheckConfig.Types.ResourceGroup) resource_ : null; }
      set {
        resource_ = value;
        resourceCase_ = value == null ? ResourceOneofCase.None : ResourceOneofCase.ResourceGroup;
      }
    }

    /// <summary>Field number for the "http_check" field.</summary>
    public const int HttpCheckFieldNumber = 5;
    /// <summary>
    /// Contains information needed to make an HTTP or HTTPS check.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Cloud.Monitoring.V3.UptimeCheckConfig.Types.HttpCheck HttpCheck {
      get { return checkRequestTypeCase_ == CheckRequestTypeOneofCase.HttpCheck ? (global::Google.Cloud.Monitoring.V3.UptimeCheckConfig.Types.HttpCheck) checkRequestType_ : null; }
      set {
        checkRequestType_ = value;
        checkRequestTypeCase_ = value == null ? CheckRequestTypeOneofCase.None : CheckRequestTypeOneofCase.HttpCheck;
      }
    }

    /// <summary>Field number for the "tcp_check" field.</summary>
    public const int TcpCheckFieldNumber = 6;
    /// <summary>
    /// Contains information needed to make a TCP check.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Cloud.Monitoring.V3.UptimeCheckConfig.Types.TcpCheck TcpCheck {
      get { return checkRequestTypeCase_ == CheckRequestTypeOneofCase.TcpCheck ? (global::Google.Cloud.Monitoring.V3.UptimeCheckConfig.Types.TcpCheck) checkRequestType_ : null; }
      set {
        checkRequestType_ = value;
        checkRequestTypeCase_ = value == null ? CheckRequestTypeOneofCase.None : CheckRequestTypeOneofCase.TcpCheck;
      }
    }

    /// <summary>Field number for the "period" field.</summary>
    public const int PeriodFieldNumber = 7;
    private global::Google.Protobuf.WellKnownTypes.Duration period_;
    /// <summary>
    /// How often, in seconds, the uptime check is performed.
    /// Currently, the only supported values are `60s` (1 minute), `300s`
    /// (5 minutes), `600s` (10 minutes), and `900s` (15 minutes). Optional,
    /// defaults to `300s`.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Protobuf.WellKnownTypes.Duration Period {
      get { return period_; }
      set {
        period_ = value;
      }
    }

    /// <summary>Field number for the "timeout" field.</summary>
    public const int TimeoutFieldNumber = 8;
    private global::Google.Protobuf.WellKnownTypes.Duration timeout_;
    /// <summary>
    /// The maximum amount of time to wait for the request to complete (must be
    /// between 1 and 60 seconds). Required.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Protobuf.WellKnownTypes.Duration Timeout {
      get { return timeout_; }
      set {
        timeout_ = value;
      }
    }

    /// <summary>Field number for the "content_matchers" field.</summary>
    public const int ContentMatchersFieldNumber = 9;
    private static readonly pb::FieldCodec<global::Google.Cloud.Monitoring.V3.UptimeCheckConfig.Types.ContentMatcher> _repeated_contentMatchers_codec
        = pb::FieldCodec.ForMessage(74, global::Google.Cloud.Monitoring.V3.UptimeCheckConfig.Types.ContentMatcher.Parser);
    private readonly pbc::RepeatedField<global::Google.Cloud.Monitoring.V3.UptimeCheckConfig.Types.ContentMatcher> contentMatchers_ = new pbc::RepeatedField<global::Google.Cloud.Monitoring.V3.UptimeCheckConfig.Types.ContentMatcher>();
    /// <summary>
    /// The expected content on the page the check is run against.
    /// Currently, only the first entry in the list is supported, and other entries
    /// will be ignored. The server will look for an exact match of the string in
    /// the page response's content. This field is optional and should only be
    /// specified if a content match is required.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Google.Cloud.Monitoring.V3.UptimeCheckConfig.Types.ContentMatcher> ContentMatchers {
      get { return contentMatchers_; }
    }

    /// <summary>Field number for the "selected_regions" field.</summary>
    public const int SelectedRegionsFieldNumber = 10;
    private static readonly pb::FieldCodec<global::Google.Cloud.Monitoring.V3.UptimeCheckRegion> _repeated_selectedRegions_codec
        = pb::FieldCodec.ForEnum(82, x => (int) x, x => (global::Google.Cloud.Monitoring.V3.UptimeCheckRegion) x);
    private readonly pbc::RepeatedField<global::Google.Cloud.Monitoring.V3.UptimeCheckRegion> selectedRegions_ = new pbc::RepeatedField<global::Google.Cloud.Monitoring.V3.UptimeCheckRegion>();
    /// <summary>
    /// The list of regions from which the check will be run.
    /// If this field is specified, enough regions to include a minimum of
    /// 3 locations must be provided, or an error message is returned.
    /// Not specifying this field will result in uptime checks running from all
    /// regions.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Google.Cloud.Monitoring.V3.UptimeCheckRegion> SelectedRegions {
      get { return selectedRegions_; }
    }

    /// <summary>Field number for the "is_internal" field.</summary>
    public const int IsInternalFieldNumber = 15;
    private bool isInternal_;
    /// <summary>
    /// Denotes whether this is a check that egresses from InternalCheckers.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsInternal {
      get { return isInternal_; }
      set {
        isInternal_ = value;
      }
    }

    /// <summary>Field number for the "internal_checkers" field.</summary>
    public const int InternalCheckersFieldNumber = 14;
    private static readonly pb::FieldCodec<global::Google.Cloud.Monitoring.V3.InternalChecker> _repeated_internalCheckers_codec
        = pb::FieldCodec.ForMessage(114, global::Google.Cloud.Monitoring.V3.InternalChecker.Parser);
    private readonly pbc::RepeatedField<global::Google.Cloud.Monitoring.V3.InternalChecker> internalCheckers_ = new pbc::RepeatedField<global::Google.Cloud.Monitoring.V3.InternalChecker>();
    /// <summary>
    /// The internal checkers that this check will egress from. If `is_internal` is
    /// true and this list is empty, the check will egress from all
    /// InternalCheckers configured for the project that owns this CheckConfig.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Google.Cloud.Monitoring.V3.InternalChecker> InternalCheckers {
      get { return internalCheckers_; }
    }

    private object resource_;
    /// <summary>Enum of possible cases for the "resource" oneof.</summary>
    public enum ResourceOneofCase {
      None = 0,
      MonitoredResource = 3,
      ResourceGroup = 4,
    }
    private ResourceOneofCase resourceCase_ = ResourceOneofCase.None;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ResourceOneofCase ResourceCase {
      get { return resourceCase_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearResource() {
      resourceCase_ = ResourceOneofCase.None;
      resource_ = null;
    }

    private object checkRequestType_;
    /// <summary>Enum of possible cases for the "check_request_type" oneof.</summary>
    public enum CheckRequestTypeOneofCase {
      None = 0,
      HttpCheck = 5,
      TcpCheck = 6,
    }
    private CheckRequestTypeOneofCase checkRequestTypeCase_ = CheckRequestTypeOneofCase.None;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public CheckRequestTypeOneofCase CheckRequestTypeCase {
      get { return checkRequestTypeCase_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearCheckRequestType() {
      checkRequestTypeCase_ = CheckRequestTypeOneofCase.None;
      checkRequestType_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as UptimeCheckConfig);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(UptimeCheckConfig other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Name != other.Name) return false;
      if (DisplayName != other.DisplayName) return false;
      if (!object.Equals(MonitoredResource, other.MonitoredResource)) return false;
      if (!object.Equals(ResourceGroup, other.ResourceGroup)) return false;
      if (!object.Equals(HttpCheck, other.HttpCheck)) return false;
      if (!object.Equals(TcpCheck, other.TcpCheck)) return false;
      if (!object.Equals(Period, other.Period)) return false;
      if (!object.Equals(Timeout, other.Timeout)) return false;
      if(!contentMatchers_.Equals(other.contentMatchers_)) return false;
      if(!selectedRegions_.Equals(other.selectedRegions_)) return false;
      if (IsInternal != other.IsInternal) return false;
      if(!internalCheckers_.Equals(other.internalCheckers_)) return false;
      if (ResourceCase != other.ResourceCase) return false;
      if (CheckRequestTypeCase != other.CheckRequestTypeCase) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Name.Length != 0) hash ^= Name.GetHashCode();
      if (DisplayName.Length != 0) hash ^= DisplayName.GetHashCode();
      if (resourceCase_ == ResourceOneofCase.MonitoredResource) hash ^= MonitoredResource.GetHashCode();
      if (resourceCase_ == ResourceOneofCase.ResourceGroup) hash ^= ResourceGroup.GetHashCode();
      if (checkRequestTypeCase_ == CheckRequestTypeOneofCase.HttpCheck) hash ^= HttpCheck.GetHashCode();
      if (checkRequestTypeCase_ == CheckRequestTypeOneofCase.TcpCheck) hash ^= TcpCheck.GetHashCode();
      if (period_ != null) hash ^= Period.GetHashCode();
      if (timeout_ != null) hash ^= Timeout.GetHashCode();
      hash ^= contentMatchers_.GetHashCode();
      hash ^= selectedRegions_.GetHashCode();
      if (IsInternal != false) hash ^= IsInternal.GetHashCode();
      hash ^= internalCheckers_.GetHashCode();
      hash ^= (int) resourceCase_;
      hash ^= (int) checkRequestTypeCase_;
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (Name.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Name);
      }
      if (DisplayName.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(DisplayName);
      }
      if (resourceCase_ == ResourceOneofCase.MonitoredResource) {
        output.WriteRawTag(26);
        output.WriteMessage(MonitoredResource);
      }
      if (resourceCase_ == ResourceOneofCase.ResourceGroup) {
        output.WriteRawTag(34);
        output.WriteMessage(ResourceGroup);
      }
      if (checkRequestTypeCase_ == CheckRequestTypeOneofCase.HttpCheck) {
        output.WriteRawTag(42);
        output.WriteMessage(HttpCheck);
      }
      if (checkRequestTypeCase_ == CheckRequestTypeOneofCase.TcpCheck) {
        output.WriteRawTag(50);
        output.WriteMessage(TcpCheck);
      }
      if (period_ != null) {
        output.WriteRawTag(58);
        output.WriteMessage(Period);
      }
      if (timeout_ != null) {
        output.WriteRawTag(66);
        output.WriteMessage(Timeout);
      }
      contentMatchers_.WriteTo(output, _repeated_contentMatchers_codec);
      selectedRegions_.WriteTo(output, _repeated_selectedRegions_codec);
      internalCheckers_.WriteTo(output, _repeated_internalCheckers_codec);
      if (IsInternal != false) {
        output.WriteRawTag(120);
        output.WriteBool(IsInternal);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Name.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
      }
      if (DisplayName.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(DisplayName);
      }
      if (resourceCase_ == ResourceOneofCase.MonitoredResource) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(MonitoredResource);
      }
      if (resourceCase_ == ResourceOneofCase.ResourceGroup) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(ResourceGroup);
      }
      if (checkRequestTypeCase_ == CheckRequestTypeOneofCase.HttpCheck) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(HttpCheck);
      }
      if (checkRequestTypeCase_ == CheckRequestTypeOneofCase.TcpCheck) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(TcpCheck);
      }
      if (period_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Period);
      }
      if (timeout_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Timeout);
      }
      size += contentMatchers_.CalculateSize(_repeated_contentMatchers_codec);
      size += selectedRegions_.CalculateSize(_repeated_selectedRegions_codec);
      if (IsInternal != false) {
        size += 1 + 1;
      }
      size += internalCheckers_.CalculateSize(_repeated_internalCheckers_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(UptimeCheckConfig other) {
      if (other == null) {
        return;
      }
      if (other.Name.Length != 0) {
        Name = other.Name;
      }
      if (other.DisplayName.Length != 0) {
        DisplayName = other.DisplayName;
      }
      if (other.period_ != null) {
        if (period_ == null) {
          period_ = new global::Google.Protobuf.WellKnownTypes.Duration();
        }
        Period.MergeFrom(other.Period);
      }
      if (other.timeout_ != null) {
        if (timeout_ == null) {
          timeout_ = new global::Google.Protobuf.WellKnownTypes.Duration();
        }
        Timeout.MergeFrom(other.Timeout);
      }
      contentMatchers_.Add(other.contentMatchers_);
      selectedRegions_.Add(other.selectedRegions_);
      if (other.IsInternal != false) {
        IsInternal = other.IsInternal;
      }
      internalCheckers_.Add(other.internalCheckers_);
      switch (other.ResourceCase) {
        case ResourceOneofCase.MonitoredResource:
          if (MonitoredResource == null) {
            MonitoredResource = new global::Google.Api.MonitoredResource();
          }
          MonitoredResource.MergeFrom(other.MonitoredResource);
          break;
        case ResourceOneofCase.ResourceGroup:
          if (ResourceGroup == null) {
            ResourceGroup = new global::Google.Cloud.Monitoring.V3.UptimeCheckConfig.Types.ResourceGroup();
          }
          ResourceGroup.MergeFrom(other.ResourceGroup);
          break;
      }

      switch (other.CheckRequestTypeCase) {
        case CheckRequestTypeOneofCase.HttpCheck:
          if (HttpCheck == null) {
            HttpCheck = new global::Google.Cloud.Monitoring.V3.UptimeCheckConfig.Types.HttpCheck();
          }
          HttpCheck.MergeFrom(other.HttpCheck);
          break;
        case CheckRequestTypeOneofCase.TcpCheck:
          if (TcpCheck == null) {
            TcpCheck = new global::Google.Cloud.Monitoring.V3.UptimeCheckConfig.Types.TcpCheck();
          }
          TcpCheck.MergeFrom(other.TcpCheck);
          break;
      }

      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Name = input.ReadString();
            break;
          }
          case 18: {
            DisplayName = input.ReadString();
            break;
          }
          case 26: {
            global::Google.Api.MonitoredResource subBuilder = new global::Google.Api.MonitoredResource();
            if (resourceCase_ == ResourceOneofCase.MonitoredResource) {
              subBuilder.MergeFrom(MonitoredResource);
            }
            input.ReadMessage(subBuilder);
            MonitoredResource = subBuilder;
            break;
          }
          case 34: {
            global::Google.Cloud.Monitoring.V3.UptimeCheckConfig.Types.ResourceGroup subBuilder = new global::Google.Cloud.Monitoring.V3.UptimeCheckConfig.Types.ResourceGroup();
            if (resourceCase_ == ResourceOneofCase.ResourceGroup) {
              subBuilder.MergeFrom(ResourceGroup);
            }
            input.ReadMessage(subBuilder);
            ResourceGroup = subBuilder;
            break;
          }
          case 42: {
            global::Google.Cloud.Monitoring.V3.UptimeCheckConfig.Types.HttpCheck subBuilder = new global::Google.Cloud.Monitoring.V3.UptimeCheckConfig.Types.HttpCheck();
            if (checkRequestTypeCase_ == CheckRequestTypeOneofCase.HttpCheck) {
              subBuilder.MergeFrom(HttpCheck);
            }
            input.ReadMessage(subBuilder);
            HttpCheck = subBuilder;
            break;
          }
          case 50: {
            global::Google.Cloud.Monitoring.V3.UptimeCheckConfig.Types.TcpCheck subBuilder = new global::Google.Cloud.Monitoring.V3.UptimeCheckConfig.Types.TcpCheck();
            if (checkRequestTypeCase_ == CheckRequestTypeOneofCase.TcpCheck) {
              subBuilder.MergeFrom(TcpCheck);
            }
            input.ReadMessage(subBuilder);
            TcpCheck = subBuilder;
            break;
          }
          case 58: {
            if (period_ == null) {
              period_ = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            input.ReadMessage(period_);
            break;
          }
          case 66: {
            if (timeout_ == null) {
              timeout_ = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            input.ReadMessage(timeout_);
            break;
          }
          case 74: {
            contentMatchers_.AddEntriesFrom(input, _repeated_contentMatchers_codec);
            break;
          }
          case 82:
          case 80: {
            selectedRegions_.AddEntriesFrom(input, _repeated_selectedRegions_codec);
            break;
          }
          case 114: {
            internalCheckers_.AddEntriesFrom(input, _repeated_internalCheckers_codec);
            break;
          }
          case 120: {
            IsInternal = input.ReadBool();
            break;
          }
        }
      }
    }

    #region Nested types
    /// <summary>Container for nested types declared in the UptimeCheckConfig message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      /// <summary>
      /// The resource submessage for group checks. It can be used instead of a
      /// monitored resource, when multiple resources are being monitored.
      /// </summary>
      public sealed partial class ResourceGroup : pb::IMessage<ResourceGroup> {
        private static readonly pb::MessageParser<ResourceGroup> _parser = new pb::MessageParser<ResourceGroup>(() => new ResourceGroup());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<ResourceGroup> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Google.Cloud.Monitoring.V3.UptimeCheckConfig.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public ResourceGroup() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public ResourceGroup(ResourceGroup other) : this() {
          groupId_ = other.groupId_;
          resourceType_ = other.resourceType_;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public ResourceGroup Clone() {
          return new ResourceGroup(this);
        }

        /// <summary>Field number for the "group_id" field.</summary>
        public const int GroupIdFieldNumber = 1;
        private string groupId_ = "";
        /// <summary>
        /// The group of resources being monitored. Should be only the
        /// group_id, not projects/&lt;project_id>/groups/&lt;group_id>.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public string GroupId {
          get { return groupId_; }
          set {
            groupId_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }

        /// <summary>Field number for the "resource_type" field.</summary>
        public const int ResourceTypeFieldNumber = 2;
        private global::Google.Cloud.Monitoring.V3.GroupResourceType resourceType_ = 0;
        /// <summary>
        /// The resource type of the group members.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Google.Cloud.Monitoring.V3.GroupResourceType ResourceType {
          get { return resourceType_; }
          set {
            resourceType_ = value;
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as ResourceGroup);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(ResourceGroup other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (GroupId != other.GroupId) return false;
          if (ResourceType != other.ResourceType) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (GroupId.Length != 0) hash ^= GroupId.GetHashCode();
          if (ResourceType != 0) hash ^= ResourceType.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          if (GroupId.Length != 0) {
            output.WriteRawTag(10);
            output.WriteString(GroupId);
          }
          if (ResourceType != 0) {
            output.WriteRawTag(16);
            output.WriteEnum((int) ResourceType);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (GroupId.Length != 0) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(GroupId);
          }
          if (ResourceType != 0) {
            size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) ResourceType);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(ResourceGroup other) {
          if (other == null) {
            return;
          }
          if (other.GroupId.Length != 0) {
            GroupId = other.GroupId;
          }
          if (other.ResourceType != 0) {
            ResourceType = other.ResourceType;
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 10: {
                GroupId = input.ReadString();
                break;
              }
              case 16: {
                resourceType_ = (global::Google.Cloud.Monitoring.V3.GroupResourceType) input.ReadEnum();
                break;
              }
            }
          }
        }

      }

      /// <summary>
      /// Information involved in an HTTP/HTTPS uptime check request.
      /// </summary>
      public sealed partial class HttpCheck : pb::IMessage<HttpCheck> {
        private static readonly pb::MessageParser<HttpCheck> _parser = new pb::MessageParser<HttpCheck>(() => new HttpCheck());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<HttpCheck> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Google.Cloud.Monitoring.V3.UptimeCheckConfig.Descriptor.NestedTypes[1]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public HttpCheck() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public HttpCheck(HttpCheck other) : this() {
          useSsl_ = other.useSsl_;
          path_ = other.path_;
          port_ = other.port_;
          authInfo_ = other.authInfo_ != null ? other.authInfo_.Clone() : null;
          maskHeaders_ = other.maskHeaders_;
          headers_ = other.headers_.Clone();
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public HttpCheck Clone() {
          return new HttpCheck(this);
        }

        /// <summary>Field number for the "use_ssl" field.</summary>
        public const int UseSslFieldNumber = 1;
        private bool useSsl_;
        /// <summary>
        /// If true, use HTTPS instead of HTTP to run the check.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool UseSsl {
          get { return useSsl_; }
          set {
            useSsl_ = value;
          }
        }

        /// <summary>Field number for the "path" field.</summary>
        public const int PathFieldNumber = 2;
        private string path_ = "";
        /// <summary>
        /// The path to the page to run the check against. Will be combined with the
        /// host (specified within the MonitoredResource) and port to construct the
        /// full URL. Optional (defaults to "/").
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public string Path {
          get { return path_; }
          set {
            path_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }

        /// <summary>Field number for the "port" field.</summary>
        public const int PortFieldNumber = 3;
        private int port_;
        /// <summary>
        /// The port to the page to run the check against. Will be combined with host
        /// (specified within the MonitoredResource) and path to construct the full
        /// URL. Optional (defaults to 80 without SSL, or 443 with SSL).
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int Port {
          get { return port_; }
          set {
            port_ = value;
          }
        }

        /// <summary>Field number for the "auth_info" field.</summary>
        public const int AuthInfoFieldNumber = 4;
        private global::Google.Cloud.Monitoring.V3.UptimeCheckConfig.Types.HttpCheck.Types.BasicAuthentication authInfo_;
        /// <summary>
        /// The authentication information. Optional when creating an HTTP check;
        /// defaults to empty.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Google.Cloud.Monitoring.V3.UptimeCheckConfig.Types.HttpCheck.Types.BasicAuthentication AuthInfo {
          get { return authInfo_; }
          set {
            authInfo_ = value;
          }
        }

        /// <summary>Field number for the "mask_headers" field.</summary>
        public const int MaskHeadersFieldNumber = 5;
        private bool maskHeaders_;
        /// <summary>
        /// Boolean specifiying whether to encrypt the header information.
        /// Encryption should be specified for any headers related to authentication
        /// that you do not wish to be seen when retrieving the configuration. The
        /// server will be responsible for encrypting the headers.
        /// On Get/List calls, if mask_headers is set to True then the headers
        /// will be obscured with ******.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool MaskHeaders {
          get { return maskHeaders_; }
          set {
            maskHeaders_ = value;
          }
        }

        /// <summary>Field number for the "headers" field.</summary>
        public const int HeadersFieldNumber = 6;
        private static readonly pbc::MapField<string, string>.Codec _map_headers_codec
            = new pbc::MapField<string, string>.Codec(pb::FieldCodec.ForString(10), pb::FieldCodec.ForString(18), 50);
        private readonly pbc::MapField<string, string> headers_ = new pbc::MapField<string, string>();
        /// <summary>
        /// The list of headers to send as part of the uptime check request.
        /// If two headers have the same key and different values, they should
        /// be entered as a single header, with the value being a comma-separated
        /// list of all the desired values as described at
        /// https://www.w3.org/Protocols/rfc2616/rfc2616.txt (page 31).
        /// Entering two separate headers with the same key in a Create call will
        /// cause the first to be overwritten by the second.
        /// The maximum number of headers allowed is 100.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public pbc::MapField<string, string> Headers {
          get { return headers_; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as HttpCheck);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(HttpCheck other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (UseSsl != other.UseSsl) return false;
          if (Path != other.Path) return false;
          if (Port != other.Port) return false;
          if (!object.Equals(AuthInfo, other.AuthInfo)) return false;
          if (MaskHeaders != other.MaskHeaders) return false;
          if (!Headers.Equals(other.Headers)) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (UseSsl != false) hash ^= UseSsl.GetHashCode();
          if (Path.Length != 0) hash ^= Path.GetHashCode();
          if (Port != 0) hash ^= Port.GetHashCode();
          if (authInfo_ != null) hash ^= AuthInfo.GetHashCode();
          if (MaskHeaders != false) hash ^= MaskHeaders.GetHashCode();
          hash ^= Headers.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          if (UseSsl != false) {
            output.WriteRawTag(8);
            output.WriteBool(UseSsl);
          }
          if (Path.Length != 0) {
            output.WriteRawTag(18);
            output.WriteString(Path);
          }
          if (Port != 0) {
            output.WriteRawTag(24);
            output.WriteInt32(Port);
          }
          if (authInfo_ != null) {
            output.WriteRawTag(34);
            output.WriteMessage(AuthInfo);
          }
          if (MaskHeaders != false) {
            output.WriteRawTag(40);
            output.WriteBool(MaskHeaders);
          }
          headers_.WriteTo(output, _map_headers_codec);
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (UseSsl != false) {
            size += 1 + 1;
          }
          if (Path.Length != 0) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(Path);
          }
          if (Port != 0) {
            size += 1 + pb::CodedOutputStream.ComputeInt32Size(Port);
          }
          if (authInfo_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(AuthInfo);
          }
          if (MaskHeaders != false) {
            size += 1 + 1;
          }
          size += headers_.CalculateSize(_map_headers_codec);
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(HttpCheck other) {
          if (other == null) {
            return;
          }
          if (other.UseSsl != false) {
            UseSsl = other.UseSsl;
          }
          if (other.Path.Length != 0) {
            Path = other.Path;
          }
          if (other.Port != 0) {
            Port = other.Port;
          }
          if (other.authInfo_ != null) {
            if (authInfo_ == null) {
              authInfo_ = new global::Google.Cloud.Monitoring.V3.UptimeCheckConfig.Types.HttpCheck.Types.BasicAuthentication();
            }
            AuthInfo.MergeFrom(other.AuthInfo);
          }
          if (other.MaskHeaders != false) {
            MaskHeaders = other.MaskHeaders;
          }
          headers_.Add(other.headers_);
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 8: {
                UseSsl = input.ReadBool();
                break;
              }
              case 18: {
                Path = input.ReadString();
                break;
              }
              case 24: {
                Port = input.ReadInt32();
                break;
              }
              case 34: {
                if (authInfo_ == null) {
                  authInfo_ = new global::Google.Cloud.Monitoring.V3.UptimeCheckConfig.Types.HttpCheck.Types.BasicAuthentication();
                }
                input.ReadMessage(authInfo_);
                break;
              }
              case 40: {
                MaskHeaders = input.ReadBool();
                break;
              }
              case 50: {
                headers_.AddEntriesFrom(input, _map_headers_codec);
                break;
              }
            }
          }
        }

        #region Nested types
        /// <summary>Container for nested types declared in the HttpCheck message type.</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static partial class Types {
          /// <summary>
          /// A type of authentication to perform against the specified resource or URL
          /// that uses username and password.
          /// Currently, only Basic authentication is supported in Uptime Monitoring.
          /// </summary>
          public sealed partial class BasicAuthentication : pb::IMessage<BasicAuthentication> {
            private static readonly pb::MessageParser<BasicAuthentication> _parser = new pb::MessageParser<BasicAuthentication>(() => new BasicAuthentication());
            private pb::UnknownFieldSet _unknownFields;
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public static pb::MessageParser<BasicAuthentication> Parser { get { return _parser; } }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public static pbr::MessageDescriptor Descriptor {
              get { return global::Google.Cloud.Monitoring.V3.UptimeCheckConfig.Types.HttpCheck.Descriptor.NestedTypes[0]; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            pbr::MessageDescriptor pb::IMessage.Descriptor {
              get { return Descriptor; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public BasicAuthentication() {
              OnConstruction();
            }

            partial void OnConstruction();

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public BasicAuthentication(BasicAuthentication other) : this() {
              username_ = other.username_;
              password_ = other.password_;
              _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public BasicAuthentication Clone() {
              return new BasicAuthentication(this);
            }

            /// <summary>Field number for the "username" field.</summary>
            public const int UsernameFieldNumber = 1;
            private string username_ = "";
            /// <summary>
            /// The username to authenticate.
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public string Username {
              get { return username_; }
              set {
                username_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
              }
            }

            /// <summary>Field number for the "password" field.</summary>
            public const int PasswordFieldNumber = 2;
            private string password_ = "";
            /// <summary>
            /// The password to authenticate.
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public string Password {
              get { return password_; }
              set {
                password_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
              }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public override bool Equals(object other) {
              return Equals(other as BasicAuthentication);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public bool Equals(BasicAuthentication other) {
              if (ReferenceEquals(other, null)) {
                return false;
              }
              if (ReferenceEquals(other, this)) {
                return true;
              }
              if (Username != other.Username) return false;
              if (Password != other.Password) return false;
              return Equals(_unknownFields, other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public override int GetHashCode() {
              int hash = 1;
              if (Username.Length != 0) hash ^= Username.GetHashCode();
              if (Password.Length != 0) hash ^= Password.GetHashCode();
              if (_unknownFields != null) {
                hash ^= _unknownFields.GetHashCode();
              }
              return hash;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public override string ToString() {
              return pb::JsonFormatter.ToDiagnosticString(this);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public void WriteTo(pb::CodedOutputStream output) {
              if (Username.Length != 0) {
                output.WriteRawTag(10);
                output.WriteString(Username);
              }
              if (Password.Length != 0) {
                output.WriteRawTag(18);
                output.WriteString(Password);
              }
              if (_unknownFields != null) {
                _unknownFields.WriteTo(output);
              }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public int CalculateSize() {
              int size = 0;
              if (Username.Length != 0) {
                size += 1 + pb::CodedOutputStream.ComputeStringSize(Username);
              }
              if (Password.Length != 0) {
                size += 1 + pb::CodedOutputStream.ComputeStringSize(Password);
              }
              if (_unknownFields != null) {
                size += _unknownFields.CalculateSize();
              }
              return size;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public void MergeFrom(BasicAuthentication other) {
              if (other == null) {
                return;
              }
              if (other.Username.Length != 0) {
                Username = other.Username;
              }
              if (other.Password.Length != 0) {
                Password = other.Password;
              }
              _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public void MergeFrom(pb::CodedInputStream input) {
              uint tag;
              while ((tag = input.ReadTag()) != 0) {
                switch(tag) {
                  default:
                    _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                    break;
                  case 10: {
                    Username = input.ReadString();
                    break;
                  }
                  case 18: {
                    Password = input.ReadString();
                    break;
                  }
                }
              }
            }

          }

        }
        #endregion

      }

      /// <summary>
      /// Information required for a TCP uptime check request.
      /// </summary>
      public sealed partial class TcpCheck : pb::IMessage<TcpCheck> {
        private static readonly pb::MessageParser<TcpCheck> _parser = new pb::MessageParser<TcpCheck>(() => new TcpCheck());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<TcpCheck> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Google.Cloud.Monitoring.V3.UptimeCheckConfig.Descriptor.NestedTypes[2]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public TcpCheck() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public TcpCheck(TcpCheck other) : this() {
          port_ = other.port_;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public TcpCheck Clone() {
          return new TcpCheck(this);
        }

        /// <summary>Field number for the "port" field.</summary>
        public const int PortFieldNumber = 1;
        private int port_;
        /// <summary>
        /// The port to the page to run the check against. Will be combined with host
        /// (specified within the MonitoredResource) to construct the full URL.
        /// Required.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int Port {
          get { return port_; }
          set {
            port_ = value;
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as TcpCheck);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(TcpCheck other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (Port != other.Port) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (Port != 0) hash ^= Port.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          if (Port != 0) {
            output.WriteRawTag(8);
            output.WriteInt32(Port);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (Port != 0) {
            size += 1 + pb::CodedOutputStream.ComputeInt32Size(Port);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(TcpCheck other) {
          if (other == null) {
            return;
          }
          if (other.Port != 0) {
            Port = other.Port;
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 8: {
                Port = input.ReadInt32();
                break;
              }
            }
          }
        }

      }

      /// <summary>
      /// Used to perform string matching. Currently, this matches on the exact
      /// content. In the future, it can be expanded to allow for regular expressions
      /// and more complex matching.
      /// </summary>
      public sealed partial class ContentMatcher : pb::IMessage<ContentMatcher> {
        private static readonly pb::MessageParser<ContentMatcher> _parser = new pb::MessageParser<ContentMatcher>(() => new ContentMatcher());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<ContentMatcher> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Google.Cloud.Monitoring.V3.UptimeCheckConfig.Descriptor.NestedTypes[3]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public ContentMatcher() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public ContentMatcher(ContentMatcher other) : this() {
          content_ = other.content_;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public ContentMatcher Clone() {
          return new ContentMatcher(this);
        }

        /// <summary>Field number for the "content" field.</summary>
        public const int ContentFieldNumber = 1;
        private string content_ = "";
        /// <summary>
        /// String content to match (max 1024 bytes)
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public string Content {
          get { return content_; }
          set {
            content_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as ContentMatcher);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(ContentMatcher other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (Content != other.Content) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (Content.Length != 0) hash ^= Content.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          if (Content.Length != 0) {
            output.WriteRawTag(10);
            output.WriteString(Content);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (Content.Length != 0) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(Content);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(ContentMatcher other) {
          if (other == null) {
            return;
          }
          if (other.Content.Length != 0) {
            Content = other.Content;
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 10: {
                Content = input.ReadString();
                break;
              }
            }
          }
        }

      }

    }
    #endregion

  }

  /// <summary>
  /// Contains the region, location, and list of IP
  /// addresses where checkers in the location run from.
  /// </summary>
  public sealed partial class UptimeCheckIp : pb::IMessage<UptimeCheckIp> {
    private static readonly pb::MessageParser<UptimeCheckIp> _parser = new pb::MessageParser<UptimeCheckIp>(() => new UptimeCheckIp());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<UptimeCheckIp> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Cloud.Monitoring.V3.UptimeReflection.Descriptor.MessageTypes[2]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public UptimeCheckIp() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public UptimeCheckIp(UptimeCheckIp other) : this() {
      region_ = other.region_;
      location_ = other.location_;
      ipAddress_ = other.ipAddress_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public UptimeCheckIp Clone() {
      return new UptimeCheckIp(this);
    }

    /// <summary>Field number for the "region" field.</summary>
    public const int RegionFieldNumber = 1;
    private global::Google.Cloud.Monitoring.V3.UptimeCheckRegion region_ = 0;
    /// <summary>
    /// A broad region category in which the IP address is located.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Cloud.Monitoring.V3.UptimeCheckRegion Region {
      get { return region_; }
      set {
        region_ = value;
      }
    }

    /// <summary>Field number for the "location" field.</summary>
    public const int LocationFieldNumber = 2;
    private string location_ = "";
    /// <summary>
    /// A more specific location within the region that typically encodes
    /// a particular city/town/metro (and its containing state/province or country)
    /// within the broader umbrella region category.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Location {
      get { return location_; }
      set {
        location_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "ip_address" field.</summary>
    public const int IpAddressFieldNumber = 3;
    private string ipAddress_ = "";
    /// <summary>
    /// The IP address from which the uptime check originates. This is a full
    /// IP address (not an IP address range). Most IP addresses, as of this
    /// publication, are in IPv4 format; however, one should not rely on the
    /// IP addresses being in IPv4 format indefinitely and should support
    /// interpreting this field in either IPv4 or IPv6 format.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string IpAddress {
      get { return ipAddress_; }
      set {
        ipAddress_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as UptimeCheckIp);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(UptimeCheckIp other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Region != other.Region) return false;
      if (Location != other.Location) return false;
      if (IpAddress != other.IpAddress) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Region != 0) hash ^= Region.GetHashCode();
      if (Location.Length != 0) hash ^= Location.GetHashCode();
      if (IpAddress.Length != 0) hash ^= IpAddress.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (Region != 0) {
        output.WriteRawTag(8);
        output.WriteEnum((int) Region);
      }
      if (Location.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(Location);
      }
      if (IpAddress.Length != 0) {
        output.WriteRawTag(26);
        output.WriteString(IpAddress);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Region != 0) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Region);
      }
      if (Location.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Location);
      }
      if (IpAddress.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(IpAddress);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(UptimeCheckIp other) {
      if (other == null) {
        return;
      }
      if (other.Region != 0) {
        Region = other.Region;
      }
      if (other.Location.Length != 0) {
        Location = other.Location;
      }
      if (other.IpAddress.Length != 0) {
        IpAddress = other.IpAddress;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            region_ = (global::Google.Cloud.Monitoring.V3.UptimeCheckRegion) input.ReadEnum();
            break;
          }
          case 18: {
            Location = input.ReadString();
            break;
          }
          case 26: {
            IpAddress = input.ReadString();
            break;
          }
        }
      }
    }

  }

  #endregion

}

#endregion Designer generated code
