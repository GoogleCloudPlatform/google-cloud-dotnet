// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: google/cloud/talent/v4beta1/filters.proto
// </auto-generated>
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace Google.Cloud.Talent.V4Beta1 {

  /// <summary>Holder for reflection information generated from google/cloud/talent/v4beta1/filters.proto</summary>
  public static partial class FiltersReflection {

    #region Descriptor
    /// <summary>File descriptor for google/cloud/talent/v4beta1/filters.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static FiltersReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "Cilnb29nbGUvY2xvdWQvdGFsZW50L3Y0YmV0YTEvZmlsdGVycy5wcm90bxIb",
            "Z29vZ2xlLmNsb3VkLnRhbGVudC52NGJldGExGhxnb29nbGUvYXBpL2Fubm90",
            "YXRpb25zLnByb3RvGihnb29nbGUvY2xvdWQvdGFsZW50L3Y0YmV0YTEvY29t",
            "bW9uLnByb3RvGiVnb29nbGUvY2xvdWQvdGFsZW50L3Y0YmV0YTEvam9iLnBy",
            "b3RvGilnb29nbGUvY2xvdWQvdGFsZW50L3Y0YmV0YTEvcHJvZmlsZS5wcm90",
            "bxoeZ29vZ2xlL3Byb3RvYnVmL2R1cmF0aW9uLnByb3RvGh9nb29nbGUvcHJv",
            "dG9idWYvdGltZXN0YW1wLnByb3RvGh5nb29nbGUvcHJvdG9idWYvd3JhcHBl",
            "cnMucHJvdG8aFmdvb2dsZS90eXBlL2RhdGUucHJvdG8aGGdvb2dsZS90eXBl",
            "L2xhdGxuZy5wcm90bxobZ29vZ2xlL3R5cGUvdGltZW9mZGF5LnByb3RvIucE",
            "CghKb2JRdWVyeRINCgVxdWVyeRgBIAEoCRIVCg1jb21wYW55X25hbWVzGAIg",
            "AygJEkUKEGxvY2F0aW9uX2ZpbHRlcnMYAyADKAsyKy5nb29nbGUuY2xvdWQu",
            "dGFsZW50LnY0YmV0YTEuTG9jYXRpb25GaWx0ZXISQAoOam9iX2NhdGVnb3Jp",
            "ZXMYBCADKA4yKC5nb29nbGUuY2xvdWQudGFsZW50LnY0YmV0YTEuSm9iQ2F0",
            "ZWdvcnkSQgoOY29tbXV0ZV9maWx0ZXIYBSABKAsyKi5nb29nbGUuY2xvdWQu",
            "dGFsZW50LnY0YmV0YTEuQ29tbXV0ZUZpbHRlchIdChVjb21wYW55X2Rpc3Bs",
            "YXlfbmFtZXMYBiADKAkSTAoTY29tcGVuc2F0aW9uX2ZpbHRlchgHIAEoCzIv",
            "Lmdvb2dsZS5jbG91ZC50YWxlbnQudjRiZXRhMS5Db21wZW5zYXRpb25GaWx0",
            "ZXISHwoXY3VzdG9tX2F0dHJpYnV0ZV9maWx0ZXIYCCABKAkSGwoTZGlzYWJs",
            "ZV9zcGVsbF9jaGVjaxgJIAEoCBJFChBlbXBsb3ltZW50X3R5cGVzGAogAygO",
            "MisuZ29vZ2xlLmNsb3VkLnRhbGVudC52NGJldGExLkVtcGxveW1lbnRUeXBl",
            "EhYKDmxhbmd1YWdlX2NvZGVzGAsgAygJEkcKEnB1Ymxpc2hfdGltZV9yYW5n",
            "ZRgMIAEoCzIrLmdvb2dsZS5jbG91ZC50YWxlbnQudjRiZXRhMS5UaW1lc3Rh",
            "bXBSYW5nZRIVCg1leGNsdWRlZF9qb2JzGA0gAygJIq4ICgxQcm9maWxlUXVl",
            "cnkSDQoFcXVlcnkYASABKAkSRQoQbG9jYXRpb25fZmlsdGVycxgCIAMoCzIr",
            "Lmdvb2dsZS5jbG91ZC50YWxlbnQudjRiZXRhMS5Mb2NhdGlvbkZpbHRlchJG",
            "ChFqb2JfdGl0bGVfZmlsdGVycxgDIAMoCzIrLmdvb2dsZS5jbG91ZC50YWxl",
            "bnQudjRiZXRhMS5Kb2JUaXRsZUZpbHRlchJFChBlbXBsb3llcl9maWx0ZXJz",
            "GAQgAygLMisuZ29vZ2xlLmNsb3VkLnRhbGVudC52NGJldGExLkVtcGxveWVy",
            "RmlsdGVyEkcKEWVkdWNhdGlvbl9maWx0ZXJzGAUgAygLMiwuZ29vZ2xlLmNs",
            "b3VkLnRhbGVudC52NGJldGExLkVkdWNhdGlvbkZpbHRlchI/Cg1za2lsbF9m",
            "aWx0ZXJzGAYgAygLMiguZ29vZ2xlLmNsb3VkLnRhbGVudC52NGJldGExLlNr",
            "aWxsRmlsdGVyElEKFndvcmtfZXhwZXJpZW5jZV9maWx0ZXIYByADKAsyMS5n",
            "b29nbGUuY2xvdWQudGFsZW50LnY0YmV0YTEuV29ya0V4cGVyaWVuY2VGaWx0",
            "ZXISPQoMdGltZV9maWx0ZXJzGAggAygLMicuZ29vZ2xlLmNsb3VkLnRhbGVu",
            "dC52NGJldGExLlRpbWVGaWx0ZXISMgoOaGlyYWJsZV9maWx0ZXIYCSABKAsy",
            "Gi5nb29nbGUucHJvdG9idWYuQm9vbFZhbHVlElQKGGFwcGxpY2F0aW9uX2Rh",
            "dGVfZmlsdGVycxgKIAMoCzIyLmdvb2dsZS5jbG91ZC50YWxlbnQudjRiZXRh",
            "MS5BcHBsaWNhdGlvbkRhdGVGaWx0ZXISZwoiYXBwbGljYXRpb25fb3V0Y29t",
            "ZV9yZWFzb25fZmlsdGVycxgLIAMoCzI7Lmdvb2dsZS5jbG91ZC50YWxlbnQu",
            "djRiZXRhMS5BcHBsaWNhdGlvbk91dGNvbWVSZWFzb25GaWx0ZXISXwoeYXBw",
            "bGljYXRpb25fbGFzdF9zdGFnZV9maWx0ZXJzGAwgAygLMjcuZ29vZ2xlLmNs",
            "b3VkLnRhbGVudC52NGJldGExLkFwcGxpY2F0aW9uTGFzdFN0YWdlRmlsdGVy",
            "ElIKF2FwcGxpY2F0aW9uX2pvYl9maWx0ZXJzGA0gAygLMjEuZ29vZ2xlLmNs",
            "b3VkLnRhbGVudC52NGJldGExLkFwcGxpY2F0aW9uSm9iRmlsdGVyElgKGmFw",
            "cGxpY2F0aW9uX3N0YXR1c19maWx0ZXJzGA4gAygLMjQuZ29vZ2xlLmNsb3Vk",
            "LnRhbGVudC52NGJldGExLkFwcGxpY2F0aW9uU3RhdHVzRmlsdGVyEhsKE2N1",
            "c3RvbV9maWVsZF9maWx0ZXIYDyABKAki3wIKDkxvY2F0aW9uRmlsdGVyEg8K",
            "B2FkZHJlc3MYASABKAkSEwoLcmVnaW9uX2NvZGUYAiABKAkSJAoHbGF0X2xu",
            "ZxgDIAEoCzITLmdvb2dsZS50eXBlLkxhdExuZxIZChFkaXN0YW5jZV9pbl9t",
            "aWxlcxgEIAEoARJhChZ0ZWxlY29tbXV0ZV9wcmVmZXJlbmNlGAUgASgOMkEu",
            "Z29vZ2xlLmNsb3VkLnRhbGVudC52NGJldGExLkxvY2F0aW9uRmlsdGVyLlRl",
            "bGVjb21tdXRlUHJlZmVyZW5jZRIPCgduZWdhdGVkGAYgASgIInIKFVRlbGVj",
            "b21tdXRlUHJlZmVyZW5jZRImCiJURUxFQ09NTVVURV9QUkVGRVJFTkNFX1VO",
            "U1BFQ0lGSUVEEAASGAoUVEVMRUNPTU1VVEVfRVhDTFVERUQQARIXChNURUxF",
            "Q09NTVVURV9BTExPV0VEEAIiwAMKEkNvbXBlbnNhdGlvbkZpbHRlchJICgR0",
            "eXBlGAEgASgOMjouZ29vZ2xlLmNsb3VkLnRhbGVudC52NGJldGExLkNvbXBl",
            "bnNhdGlvbkZpbHRlci5GaWx0ZXJUeXBlEk0KBXVuaXRzGAIgAygOMj4uZ29v",
            "Z2xlLmNsb3VkLnRhbGVudC52NGJldGExLkNvbXBlbnNhdGlvbkluZm8uQ29t",
            "cGVuc2F0aW9uVW5pdBJOCgVyYW5nZRgDIAEoCzI/Lmdvb2dsZS5jbG91ZC50",
            "YWxlbnQudjRiZXRhMS5Db21wZW5zYXRpb25JbmZvLkNvbXBlbnNhdGlvblJh",
            "bmdlEjgKMGluY2x1ZGVfam9ic193aXRoX3Vuc3BlY2lmaWVkX2NvbXBlbnNh",
            "dGlvbl9yYW5nZRgEIAEoCCKGAQoKRmlsdGVyVHlwZRIbChdGSUxURVJfVFlQ",
            "RV9VTlNQRUNJRklFRBAAEg0KCVVOSVRfT05MWRABEhMKD1VOSVRfQU5EX0FN",
            "T1VOVBACEhoKFkFOTlVBTElaRURfQkFTRV9BTU9VTlQQAxIbChdBTk5VQUxJ",
            "WkVEX1RPVEFMX0FNT1VOVBAEIskECg1Db21tdXRlRmlsdGVyElAKDmNvbW11",
            "dGVfbWV0aG9kGAEgASgOMjguZ29vZ2xlLmNsb3VkLnRhbGVudC52NGJldGEx",
            "LkNvbW11dGVGaWx0ZXIuQ29tbXV0ZU1ldGhvZBIuChFzdGFydF9jb29yZGlu",
            "YXRlcxgCIAEoCzITLmdvb2dsZS50eXBlLkxhdExuZxIyCg90cmF2ZWxfZHVy",
            "YXRpb24YAyABKAsyGS5nb29nbGUucHJvdG9idWYuRHVyYXRpb24SIQoZYWxs",
            "b3dfaW1wcmVjaXNlX2FkZHJlc3NlcxgEIAEoCBJOCgxyb2FkX3RyYWZmaWMY",
            "BSABKA4yNi5nb29nbGUuY2xvdWQudGFsZW50LnY0YmV0YTEuQ29tbXV0ZUZp",
            "bHRlci5Sb2FkVHJhZmZpY0gAEjAKDmRlcGFydHVyZV90aW1lGAYgASgLMhYu",
            "Z29vZ2xlLnR5cGUuVGltZU9mRGF5SAAifQoNQ29tbXV0ZU1ldGhvZBIeChpD",
            "T01NVVRFX01FVEhPRF9VTlNQRUNJRklFRBAAEgsKB0RSSVZJTkcQARILCgdU",
            "UkFOU0lUEAISCwoHV0FMS0lORxADEg0KCUJJQ1lDTElORxAEEhYKElRSQU5T",
            "SVRfQUNDRVNTSUJMRRAFIkwKC1JvYWRUcmFmZmljEhwKGFJPQURfVFJBRkZJ",
            "Q19VTlNQRUNJRklFRBAAEhAKDFRSQUZGSUNfRlJFRRABEg0KCUJVU1lfSE9V",
            "UhACQhAKDnRyYWZmaWNfb3B0aW9uIjQKDkpvYlRpdGxlRmlsdGVyEhEKCWpv",
            "Yl90aXRsZRgBIAEoCRIPCgduZWdhdGVkGAIgASgIIi0KC1NraWxsRmlsdGVy",
            "Eg0KBXNraWxsGAEgASgJEg8KB25lZ2F0ZWQYAiABKAgioQIKDkVtcGxveWVy",
            "RmlsdGVyEhAKCGVtcGxveWVyGAEgASgJEkwKBG1vZGUYAiABKA4yPi5nb29n",
            "bGUuY2xvdWQudGFsZW50LnY0YmV0YTEuRW1wbG95ZXJGaWx0ZXIuRW1wbG95",
            "ZXJGaWx0ZXJNb2RlEg8KB25lZ2F0ZWQYAyABKAginQEKEkVtcGxveWVyRmls",
            "dGVyTW9kZRIkCiBFTVBMT1lFUl9GSUxURVJfTU9ERV9VTlNQRUNJRklFRBAA",
            "EhoKFkFMTF9FTVBMT1lNRU5UX1JFQ09SRFMQARIjCh9DVVJSRU5UX0VNUExP",
            "WU1FTlRfUkVDT1JEU19PTkxZEAISIAocUEFTVF9FTVBMT1lNRU5UX1JFQ09S",
            "RFNfT05MWRADIogBCg9FZHVjYXRpb25GaWx0ZXISDgoGc2Nob29sGAEgASgJ",
            "EhYKDmZpZWxkX29mX3N0dWR5GAIgASgJEjwKC2RlZ3JlZV90eXBlGAMgASgO",
            "MicuZ29vZ2xlLmNsb3VkLnRhbGVudC52NGJldGExLkRlZ3JlZVR5cGUSDwoH",
            "bmVnYXRlZBgGIAEoCCJ8ChRXb3JrRXhwZXJpZW5jZUZpbHRlchIxCg5taW5f",
            "ZXhwZXJpZW5jZRgBIAEoCzIZLmdvb2dsZS5wcm90b2J1Zi5EdXJhdGlvbhIx",
            "Cg5tYXhfZXhwZXJpZW5jZRgCIAEoCzIZLmdvb2dsZS5wcm90b2J1Zi5EdXJh",
            "dGlvbiJjChVBcHBsaWNhdGlvbkRhdGVGaWx0ZXISJQoKc3RhcnRfZGF0ZRgB",
            "IAEoCzIRLmdvb2dsZS50eXBlLkRhdGUSIwoIZW5kX2RhdGUYAiABKAsyES5n",
            "b29nbGUudHlwZS5EYXRlIkkKHkFwcGxpY2F0aW9uT3V0Y29tZVJlYXNvbkZp",
            "bHRlchIWCg5vdXRjb21lX3JlYXNvbhgBIAEoCRIPCgduZWdhdGVkGAIgASgI",
            "IkEKGkFwcGxpY2F0aW9uTGFzdFN0YWdlRmlsdGVyEhIKCmxhc3Rfc3RhZ2UY",
            "ASABKAkSDwoHbmVnYXRlZBgCIAEoCCJoChRBcHBsaWNhdGlvbkpvYkZpbHRl",
            "chIQCghqb2JfbmFtZRgBIAEoCRIaChJqb2JfcmVxdWlzaXRpb25faWQYAiAB",
            "KAkSEQoJam9iX3RpdGxlGAMgASgJEg8KB25lZ2F0ZWQYBCABKAgihQEKF0Fw",
            "cGxpY2F0aW9uU3RhdHVzRmlsdGVyElkKEmFwcGxpY2F0aW9uX3N0YXR1cxgB",
            "IAEoDjI9Lmdvb2dsZS5jbG91ZC50YWxlbnQudjRiZXRhMS5Kb2JBcHBsaWNh",
            "dGlvbi5BcHBsaWNhdGlvblN0YXR1cxIPCgduZWdhdGVkGAIgASgIIvwBCgpU",
            "aW1lRmlsdGVyEi4KCnN0YXJ0X3RpbWUYASABKAsyGi5nb29nbGUucHJvdG9i",
            "dWYuVGltZXN0YW1wEiwKCGVuZF90aW1lGAIgASgLMhouZ29vZ2xlLnByb3Rv",
            "YnVmLlRpbWVzdGFtcBJFCgp0aW1lX2ZpZWxkGAMgASgOMjEuZ29vZ2xlLmNs",
            "b3VkLnRhbGVudC52NGJldGExLlRpbWVGaWx0ZXIuVGltZUZpZWxkIkkKCVRp",
            "bWVGaWVsZBIaChZUSU1FX0ZJRUxEX1VOU1BFQ0lGSUVEEAASDwoLQ1JFQVRF",
            "X1RJTUUQARIPCgtVUERBVEVfVElNRRACQnoKH2NvbS5nb29nbGUuY2xvdWQu",
            "dGFsZW50LnY0YmV0YTFCDEZpbHRlcnNQcm90b1ABWkFnb29nbGUuZ29sYW5n",
            "Lm9yZy9nZW5wcm90by9nb29nbGVhcGlzL2Nsb3VkL3RhbGVudC92NGJldGEx",
            "O3RhbGVudKICA0NUU2IGcHJvdG8z"));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { global::Google.Api.AnnotationsReflection.Descriptor, global::Google.Cloud.Talent.V4Beta1.CommonReflection.Descriptor, global::Google.Cloud.Talent.V4Beta1.JobReflection.Descriptor, global::Google.Cloud.Talent.V4Beta1.ProfileReflection.Descriptor, global::Google.Protobuf.WellKnownTypes.DurationReflection.Descriptor, global::Google.Protobuf.WellKnownTypes.TimestampReflection.Descriptor, global::Google.Protobuf.WellKnownTypes.WrappersReflection.Descriptor, global::Google.Type.DateReflection.Descriptor, global::Google.Type.LatlngReflection.Descriptor, global::Google.Type.TimeofdayReflection.Descriptor, },
          new pbr::GeneratedClrTypeInfo(null, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Cloud.Talent.V4Beta1.JobQuery), global::Google.Cloud.Talent.V4Beta1.JobQuery.Parser, new[]{ "Query", "CompanyNames", "LocationFilters", "JobCategories", "CommuteFilter", "CompanyDisplayNames", "CompensationFilter", "CustomAttributeFilter", "DisableSpellCheck", "EmploymentTypes", "LanguageCodes", "PublishTimeRange", "ExcludedJobs" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Cloud.Talent.V4Beta1.ProfileQuery), global::Google.Cloud.Talent.V4Beta1.ProfileQuery.Parser, new[]{ "Query", "LocationFilters", "JobTitleFilters", "EmployerFilters", "EducationFilters", "SkillFilters", "WorkExperienceFilter", "TimeFilters", "HirableFilter", "ApplicationDateFilters", "ApplicationOutcomeReasonFilters", "ApplicationLastStageFilters", "ApplicationJobFilters", "ApplicationStatusFilters", "CustomFieldFilter" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Cloud.Talent.V4Beta1.LocationFilter), global::Google.Cloud.Talent.V4Beta1.LocationFilter.Parser, new[]{ "Address", "RegionCode", "LatLng", "DistanceInMiles", "TelecommutePreference", "Negated" }, null, new[]{ typeof(global::Google.Cloud.Talent.V4Beta1.LocationFilter.Types.TelecommutePreference) }, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Cloud.Talent.V4Beta1.CompensationFilter), global::Google.Cloud.Talent.V4Beta1.CompensationFilter.Parser, new[]{ "Type", "Units", "Range", "IncludeJobsWithUnspecifiedCompensationRange" }, null, new[]{ typeof(global::Google.Cloud.Talent.V4Beta1.CompensationFilter.Types.FilterType) }, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Cloud.Talent.V4Beta1.CommuteFilter), global::Google.Cloud.Talent.V4Beta1.CommuteFilter.Parser, new[]{ "CommuteMethod", "StartCoordinates", "TravelDuration", "AllowImpreciseAddresses", "RoadTraffic", "DepartureTime" }, new[]{ "TrafficOption" }, new[]{ typeof(global::Google.Cloud.Talent.V4Beta1.CommuteFilter.Types.CommuteMethod), typeof(global::Google.Cloud.Talent.V4Beta1.CommuteFilter.Types.RoadTraffic) }, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Cloud.Talent.V4Beta1.JobTitleFilter), global::Google.Cloud.Talent.V4Beta1.JobTitleFilter.Parser, new[]{ "JobTitle", "Negated" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Cloud.Talent.V4Beta1.SkillFilter), global::Google.Cloud.Talent.V4Beta1.SkillFilter.Parser, new[]{ "Skill", "Negated" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Cloud.Talent.V4Beta1.EmployerFilter), global::Google.Cloud.Talent.V4Beta1.EmployerFilter.Parser, new[]{ "Employer", "Mode", "Negated" }, null, new[]{ typeof(global::Google.Cloud.Talent.V4Beta1.EmployerFilter.Types.EmployerFilterMode) }, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Cloud.Talent.V4Beta1.EducationFilter), global::Google.Cloud.Talent.V4Beta1.EducationFilter.Parser, new[]{ "School", "FieldOfStudy", "DegreeType", "Negated" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Cloud.Talent.V4Beta1.WorkExperienceFilter), global::Google.Cloud.Talent.V4Beta1.WorkExperienceFilter.Parser, new[]{ "MinExperience", "MaxExperience" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Cloud.Talent.V4Beta1.ApplicationDateFilter), global::Google.Cloud.Talent.V4Beta1.ApplicationDateFilter.Parser, new[]{ "StartDate", "EndDate" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Cloud.Talent.V4Beta1.ApplicationOutcomeReasonFilter), global::Google.Cloud.Talent.V4Beta1.ApplicationOutcomeReasonFilter.Parser, new[]{ "OutcomeReason", "Negated" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Cloud.Talent.V4Beta1.ApplicationLastStageFilter), global::Google.Cloud.Talent.V4Beta1.ApplicationLastStageFilter.Parser, new[]{ "LastStage", "Negated" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Cloud.Talent.V4Beta1.ApplicationJobFilter), global::Google.Cloud.Talent.V4Beta1.ApplicationJobFilter.Parser, new[]{ "JobName", "JobRequisitionId", "JobTitle", "Negated" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Cloud.Talent.V4Beta1.ApplicationStatusFilter), global::Google.Cloud.Talent.V4Beta1.ApplicationStatusFilter.Parser, new[]{ "ApplicationStatus", "Negated" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Cloud.Talent.V4Beta1.TimeFilter), global::Google.Cloud.Talent.V4Beta1.TimeFilter.Parser, new[]{ "StartTime", "EndTime", "TimeField" }, null, new[]{ typeof(global::Google.Cloud.Talent.V4Beta1.TimeFilter.Types.TimeField) }, null)
          }));
    }
    #endregion

  }
  #region Messages
  /// <summary>
  /// Input only.
  ///
  /// The query required to perform a search query.
  /// </summary>
  public sealed partial class JobQuery : pb::IMessage<JobQuery> {
    private static readonly pb::MessageParser<JobQuery> _parser = new pb::MessageParser<JobQuery>(() => new JobQuery());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<JobQuery> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Cloud.Talent.V4Beta1.FiltersReflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public JobQuery() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public JobQuery(JobQuery other) : this() {
      query_ = other.query_;
      companyNames_ = other.companyNames_.Clone();
      locationFilters_ = other.locationFilters_.Clone();
      jobCategories_ = other.jobCategories_.Clone();
      commuteFilter_ = other.commuteFilter_ != null ? other.commuteFilter_.Clone() : null;
      companyDisplayNames_ = other.companyDisplayNames_.Clone();
      compensationFilter_ = other.compensationFilter_ != null ? other.compensationFilter_.Clone() : null;
      customAttributeFilter_ = other.customAttributeFilter_;
      disableSpellCheck_ = other.disableSpellCheck_;
      employmentTypes_ = other.employmentTypes_.Clone();
      languageCodes_ = other.languageCodes_.Clone();
      publishTimeRange_ = other.publishTimeRange_ != null ? other.publishTimeRange_.Clone() : null;
      excludedJobs_ = other.excludedJobs_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public JobQuery Clone() {
      return new JobQuery(this);
    }

    /// <summary>Field number for the "query" field.</summary>
    public const int QueryFieldNumber = 1;
    private string query_ = "";
    /// <summary>
    /// Optional.
    ///
    /// The query string that matches against the job title, description, and
    /// location fields.
    ///
    /// The maximum number of allowed characters is 255.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Query {
      get { return query_; }
      set {
        query_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "company_names" field.</summary>
    public const int CompanyNamesFieldNumber = 2;
    private static readonly pb::FieldCodec<string> _repeated_companyNames_codec
        = pb::FieldCodec.ForString(18);
    private readonly pbc::RepeatedField<string> companyNames_ = new pbc::RepeatedField<string>();
    /// <summary>
    /// Optional.
    ///
    /// This filter specifies the company entities to search against.
    ///
    /// If a value isn't specified, jobs are searched for against all
    /// companies.
    ///
    /// If multiple values are specified, jobs are searched against the
    /// companies specified.
    ///
    /// The format is "projects/{project_id}/companies/{company_id}", for example,
    /// "projects/api-test-project/companies/foo".
    ///
    /// At most 20 company filters are allowed.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<string> CompanyNames {
      get { return companyNames_; }
    }

    /// <summary>Field number for the "location_filters" field.</summary>
    public const int LocationFiltersFieldNumber = 3;
    private static readonly pb::FieldCodec<global::Google.Cloud.Talent.V4Beta1.LocationFilter> _repeated_locationFilters_codec
        = pb::FieldCodec.ForMessage(26, global::Google.Cloud.Talent.V4Beta1.LocationFilter.Parser);
    private readonly pbc::RepeatedField<global::Google.Cloud.Talent.V4Beta1.LocationFilter> locationFilters_ = new pbc::RepeatedField<global::Google.Cloud.Talent.V4Beta1.LocationFilter>();
    /// <summary>
    /// Optional.
    ///
    /// The location filter specifies geo-regions containing the jobs to
    /// search against. See [LocationFilter][google.cloud.talent.v4beta1.LocationFilter] for more information.
    ///
    /// If a location value isn't specified, jobs fitting the other search
    /// criteria are retrieved regardless of where they're located.
    ///
    /// If multiple values are specified, jobs are retrieved from any of the
    /// specified locations. If different values are specified for the
    /// [LocationFilter.distance_in_miles][google.cloud.talent.v4beta1.LocationFilter.distance_in_miles] parameter, the maximum provided
    /// distance is used for all locations.
    ///
    /// At most 5 location filters are allowed.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Google.Cloud.Talent.V4Beta1.LocationFilter> LocationFilters {
      get { return locationFilters_; }
    }

    /// <summary>Field number for the "job_categories" field.</summary>
    public const int JobCategoriesFieldNumber = 4;
    private static readonly pb::FieldCodec<global::Google.Cloud.Talent.V4Beta1.JobCategory> _repeated_jobCategories_codec
        = pb::FieldCodec.ForEnum(34, x => (int) x, x => (global::Google.Cloud.Talent.V4Beta1.JobCategory) x);
    private readonly pbc::RepeatedField<global::Google.Cloud.Talent.V4Beta1.JobCategory> jobCategories_ = new pbc::RepeatedField<global::Google.Cloud.Talent.V4Beta1.JobCategory>();
    /// <summary>
    /// Optional.
    ///
    /// The category filter specifies the categories of jobs to search against.
    /// See [Category][] for more information.
    ///
    /// If a value isn't specified, jobs from any category are searched against.
    ///
    /// If multiple values are specified, jobs from any of the specified
    /// categories are searched against.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Google.Cloud.Talent.V4Beta1.JobCategory> JobCategories {
      get { return jobCategories_; }
    }

    /// <summary>Field number for the "commute_filter" field.</summary>
    public const int CommuteFilterFieldNumber = 5;
    private global::Google.Cloud.Talent.V4Beta1.CommuteFilter commuteFilter_;
    /// <summary>
    /// Optional.
    ///
    ///  Allows filtering jobs by commute time with different travel methods (for
    ///  example, driving or public transit). Note: This only works with [COMMUTE
    ///  MODE][Mode#COMMUTE]. When specified, [JobQuery.location_filters] is
    ///  ignored.
    ///
    ///  Currently we don't support sorting by commute time.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Cloud.Talent.V4Beta1.CommuteFilter CommuteFilter {
      get { return commuteFilter_; }
      set {
        commuteFilter_ = value;
      }
    }

    /// <summary>Field number for the "company_display_names" field.</summary>
    public const int CompanyDisplayNamesFieldNumber = 6;
    private static readonly pb::FieldCodec<string> _repeated_companyDisplayNames_codec
        = pb::FieldCodec.ForString(50);
    private readonly pbc::RepeatedField<string> companyDisplayNames_ = new pbc::RepeatedField<string>();
    /// <summary>
    /// Optional.
    ///
    /// This filter specifies the exact [company display
    /// name][Company.display_name] of the jobs to search against.
    ///
    /// If a value isn't specified, jobs within the search results are
    /// associated with any company.
    ///
    /// If multiple values are specified, jobs within the search results may be
    /// associated with any of the specified companies.
    ///
    /// At most 20 company display name filters are allowed.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<string> CompanyDisplayNames {
      get { return companyDisplayNames_; }
    }

    /// <summary>Field number for the "compensation_filter" field.</summary>
    public const int CompensationFilterFieldNumber = 7;
    private global::Google.Cloud.Talent.V4Beta1.CompensationFilter compensationFilter_;
    /// <summary>
    /// Optional.
    ///
    /// This search filter is applied only to
    /// [Job.compensation_info][google.cloud.talent.v4beta1.Job.compensation_info]. For example, if the filter is specified
    /// as "Hourly job with per-hour compensation > $15", only jobs meeting
    /// these criteria are searched. If a filter isn't defined, all open jobs
    /// are searched.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Cloud.Talent.V4Beta1.CompensationFilter CompensationFilter {
      get { return compensationFilter_; }
      set {
        compensationFilter_ = value;
      }
    }

    /// <summary>Field number for the "custom_attribute_filter" field.</summary>
    public const int CustomAttributeFilterFieldNumber = 8;
    private string customAttributeFilter_ = "";
    /// <summary>
    /// Optional.
    ///
    /// This filter specifies a structured syntax to match against the
    /// [Job.custom_attributes][google.cloud.talent.v4beta1.Job.custom_attributes] marked as `filterable`.
    ///
    /// The syntax for this expression is a subset of SQL syntax.
    ///
    /// Supported operators are: `=`, `!=`, `&lt;`, `&lt;=`, `>`, and `>=` where the
    /// left of the operator is a custom field key and the right of the operator
    /// is a number or a quoted string. You must escape backslash (\\) and
    /// quote (\") characters.
    ///
    /// Supported functions are `LOWER([field_name])` to
    /// perform a case insensitive match and `EMPTY([field_name])` to filter on the
    /// existence of a key.
    ///
    /// Boolean expressions (AND/OR/NOT) are supported up to 3 levels of
    /// nesting (for example, "((A AND B AND C) OR NOT D) AND E"), a maximum of 100
    /// comparisons or functions are allowed in the expression. The expression
    /// must be &lt; 3000 bytes in length.
    ///
    /// Sample Query:
    /// `(LOWER(driving_license)="class \"a\"" OR EMPTY(driving_license)) AND
    /// driving_years > 10`
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string CustomAttributeFilter {
      get { return customAttributeFilter_; }
      set {
        customAttributeFilter_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "disable_spell_check" field.</summary>
    public const int DisableSpellCheckFieldNumber = 9;
    private bool disableSpellCheck_;
    /// <summary>
    /// Optional.
    ///
    /// This flag controls the spell-check feature. If false, the
    /// service attempts to correct a misspelled query,
    /// for example, "enginee" is corrected to "engineer".
    ///
    /// Defaults to false: a spell check is performed.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool DisableSpellCheck {
      get { return disableSpellCheck_; }
      set {
        disableSpellCheck_ = value;
      }
    }

    /// <summary>Field number for the "employment_types" field.</summary>
    public const int EmploymentTypesFieldNumber = 10;
    private static readonly pb::FieldCodec<global::Google.Cloud.Talent.V4Beta1.EmploymentType> _repeated_employmentTypes_codec
        = pb::FieldCodec.ForEnum(82, x => (int) x, x => (global::Google.Cloud.Talent.V4Beta1.EmploymentType) x);
    private readonly pbc::RepeatedField<global::Google.Cloud.Talent.V4Beta1.EmploymentType> employmentTypes_ = new pbc::RepeatedField<global::Google.Cloud.Talent.V4Beta1.EmploymentType>();
    /// <summary>
    /// Optional.
    ///
    /// The employment type filter specifies the employment type of jobs to
    /// search against, such as [EmploymentType.FULL_TIME][google.cloud.talent.v4beta1.EmploymentType.FULL_TIME].
    ///
    /// If a value isn't specified, jobs in the search results includes any
    /// employment type.
    ///
    /// If multiple values are specified, jobs in the search results include
    /// any of the specified employment types.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Google.Cloud.Talent.V4Beta1.EmploymentType> EmploymentTypes {
      get { return employmentTypes_; }
    }

    /// <summary>Field number for the "language_codes" field.</summary>
    public const int LanguageCodesFieldNumber = 11;
    private static readonly pb::FieldCodec<string> _repeated_languageCodes_codec
        = pb::FieldCodec.ForString(90);
    private readonly pbc::RepeatedField<string> languageCodes_ = new pbc::RepeatedField<string>();
    /// <summary>
    /// Optional.
    ///
    /// This filter specifies the locale of jobs to search against,
    /// for example, "en-US".
    ///
    /// If a value isn't specified, the search results can contain jobs in any
    /// locale.
    ///
    /// Language codes should be in BCP-47 format, such as "en-US" or "sr-Latn".
    /// For more information, see
    /// [Tags for Identifying Languages](https://tools.ietf.org/html/bcp47).
    ///
    /// At most 10 language code filters are allowed.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<string> LanguageCodes {
      get { return languageCodes_; }
    }

    /// <summary>Field number for the "publish_time_range" field.</summary>
    public const int PublishTimeRangeFieldNumber = 12;
    private global::Google.Cloud.Talent.V4Beta1.TimestampRange publishTimeRange_;
    /// <summary>
    /// Optional.
    ///
    /// Jobs published within a range specified by this filter are searched
    /// against.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Cloud.Talent.V4Beta1.TimestampRange PublishTimeRange {
      get { return publishTimeRange_; }
      set {
        publishTimeRange_ = value;
      }
    }

    /// <summary>Field number for the "excluded_jobs" field.</summary>
    public const int ExcludedJobsFieldNumber = 13;
    private static readonly pb::FieldCodec<string> _repeated_excludedJobs_codec
        = pb::FieldCodec.ForString(106);
    private readonly pbc::RepeatedField<string> excludedJobs_ = new pbc::RepeatedField<string>();
    /// <summary>
    /// Optional.
    ///
    /// This filter specifies a list of job names to be excluded during search.
    ///
    /// At most 200 excluded job names are allowed.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<string> ExcludedJobs {
      get { return excludedJobs_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as JobQuery);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(JobQuery other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Query != other.Query) return false;
      if(!companyNames_.Equals(other.companyNames_)) return false;
      if(!locationFilters_.Equals(other.locationFilters_)) return false;
      if(!jobCategories_.Equals(other.jobCategories_)) return false;
      if (!object.Equals(CommuteFilter, other.CommuteFilter)) return false;
      if(!companyDisplayNames_.Equals(other.companyDisplayNames_)) return false;
      if (!object.Equals(CompensationFilter, other.CompensationFilter)) return false;
      if (CustomAttributeFilter != other.CustomAttributeFilter) return false;
      if (DisableSpellCheck != other.DisableSpellCheck) return false;
      if(!employmentTypes_.Equals(other.employmentTypes_)) return false;
      if(!languageCodes_.Equals(other.languageCodes_)) return false;
      if (!object.Equals(PublishTimeRange, other.PublishTimeRange)) return false;
      if(!excludedJobs_.Equals(other.excludedJobs_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Query.Length != 0) hash ^= Query.GetHashCode();
      hash ^= companyNames_.GetHashCode();
      hash ^= locationFilters_.GetHashCode();
      hash ^= jobCategories_.GetHashCode();
      if (commuteFilter_ != null) hash ^= CommuteFilter.GetHashCode();
      hash ^= companyDisplayNames_.GetHashCode();
      if (compensationFilter_ != null) hash ^= CompensationFilter.GetHashCode();
      if (CustomAttributeFilter.Length != 0) hash ^= CustomAttributeFilter.GetHashCode();
      if (DisableSpellCheck != false) hash ^= DisableSpellCheck.GetHashCode();
      hash ^= employmentTypes_.GetHashCode();
      hash ^= languageCodes_.GetHashCode();
      if (publishTimeRange_ != null) hash ^= PublishTimeRange.GetHashCode();
      hash ^= excludedJobs_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (Query.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Query);
      }
      companyNames_.WriteTo(output, _repeated_companyNames_codec);
      locationFilters_.WriteTo(output, _repeated_locationFilters_codec);
      jobCategories_.WriteTo(output, _repeated_jobCategories_codec);
      if (commuteFilter_ != null) {
        output.WriteRawTag(42);
        output.WriteMessage(CommuteFilter);
      }
      companyDisplayNames_.WriteTo(output, _repeated_companyDisplayNames_codec);
      if (compensationFilter_ != null) {
        output.WriteRawTag(58);
        output.WriteMessage(CompensationFilter);
      }
      if (CustomAttributeFilter.Length != 0) {
        output.WriteRawTag(66);
        output.WriteString(CustomAttributeFilter);
      }
      if (DisableSpellCheck != false) {
        output.WriteRawTag(72);
        output.WriteBool(DisableSpellCheck);
      }
      employmentTypes_.WriteTo(output, _repeated_employmentTypes_codec);
      languageCodes_.WriteTo(output, _repeated_languageCodes_codec);
      if (publishTimeRange_ != null) {
        output.WriteRawTag(98);
        output.WriteMessage(PublishTimeRange);
      }
      excludedJobs_.WriteTo(output, _repeated_excludedJobs_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Query.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Query);
      }
      size += companyNames_.CalculateSize(_repeated_companyNames_codec);
      size += locationFilters_.CalculateSize(_repeated_locationFilters_codec);
      size += jobCategories_.CalculateSize(_repeated_jobCategories_codec);
      if (commuteFilter_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(CommuteFilter);
      }
      size += companyDisplayNames_.CalculateSize(_repeated_companyDisplayNames_codec);
      if (compensationFilter_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(CompensationFilter);
      }
      if (CustomAttributeFilter.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(CustomAttributeFilter);
      }
      if (DisableSpellCheck != false) {
        size += 1 + 1;
      }
      size += employmentTypes_.CalculateSize(_repeated_employmentTypes_codec);
      size += languageCodes_.CalculateSize(_repeated_languageCodes_codec);
      if (publishTimeRange_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(PublishTimeRange);
      }
      size += excludedJobs_.CalculateSize(_repeated_excludedJobs_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(JobQuery other) {
      if (other == null) {
        return;
      }
      if (other.Query.Length != 0) {
        Query = other.Query;
      }
      companyNames_.Add(other.companyNames_);
      locationFilters_.Add(other.locationFilters_);
      jobCategories_.Add(other.jobCategories_);
      if (other.commuteFilter_ != null) {
        if (commuteFilter_ == null) {
          commuteFilter_ = new global::Google.Cloud.Talent.V4Beta1.CommuteFilter();
        }
        CommuteFilter.MergeFrom(other.CommuteFilter);
      }
      companyDisplayNames_.Add(other.companyDisplayNames_);
      if (other.compensationFilter_ != null) {
        if (compensationFilter_ == null) {
          compensationFilter_ = new global::Google.Cloud.Talent.V4Beta1.CompensationFilter();
        }
        CompensationFilter.MergeFrom(other.CompensationFilter);
      }
      if (other.CustomAttributeFilter.Length != 0) {
        CustomAttributeFilter = other.CustomAttributeFilter;
      }
      if (other.DisableSpellCheck != false) {
        DisableSpellCheck = other.DisableSpellCheck;
      }
      employmentTypes_.Add(other.employmentTypes_);
      languageCodes_.Add(other.languageCodes_);
      if (other.publishTimeRange_ != null) {
        if (publishTimeRange_ == null) {
          publishTimeRange_ = new global::Google.Cloud.Talent.V4Beta1.TimestampRange();
        }
        PublishTimeRange.MergeFrom(other.PublishTimeRange);
      }
      excludedJobs_.Add(other.excludedJobs_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Query = input.ReadString();
            break;
          }
          case 18: {
            companyNames_.AddEntriesFrom(input, _repeated_companyNames_codec);
            break;
          }
          case 26: {
            locationFilters_.AddEntriesFrom(input, _repeated_locationFilters_codec);
            break;
          }
          case 34:
          case 32: {
            jobCategories_.AddEntriesFrom(input, _repeated_jobCategories_codec);
            break;
          }
          case 42: {
            if (commuteFilter_ == null) {
              commuteFilter_ = new global::Google.Cloud.Talent.V4Beta1.CommuteFilter();
            }
            input.ReadMessage(commuteFilter_);
            break;
          }
          case 50: {
            companyDisplayNames_.AddEntriesFrom(input, _repeated_companyDisplayNames_codec);
            break;
          }
          case 58: {
            if (compensationFilter_ == null) {
              compensationFilter_ = new global::Google.Cloud.Talent.V4Beta1.CompensationFilter();
            }
            input.ReadMessage(compensationFilter_);
            break;
          }
          case 66: {
            CustomAttributeFilter = input.ReadString();
            break;
          }
          case 72: {
            DisableSpellCheck = input.ReadBool();
            break;
          }
          case 82:
          case 80: {
            employmentTypes_.AddEntriesFrom(input, _repeated_employmentTypes_codec);
            break;
          }
          case 90: {
            languageCodes_.AddEntriesFrom(input, _repeated_languageCodes_codec);
            break;
          }
          case 98: {
            if (publishTimeRange_ == null) {
              publishTimeRange_ = new global::Google.Cloud.Talent.V4Beta1.TimestampRange();
            }
            input.ReadMessage(publishTimeRange_);
            break;
          }
          case 106: {
            excludedJobs_.AddEntriesFrom(input, _repeated_excludedJobs_codec);
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// Filters to apply when performing the search query.
  /// </summary>
  public sealed partial class ProfileQuery : pb::IMessage<ProfileQuery> {
    private static readonly pb::MessageParser<ProfileQuery> _parser = new pb::MessageParser<ProfileQuery>(() => new ProfileQuery());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<ProfileQuery> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Cloud.Talent.V4Beta1.FiltersReflection.Descriptor.MessageTypes[1]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ProfileQuery() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ProfileQuery(ProfileQuery other) : this() {
      query_ = other.query_;
      locationFilters_ = other.locationFilters_.Clone();
      jobTitleFilters_ = other.jobTitleFilters_.Clone();
      employerFilters_ = other.employerFilters_.Clone();
      educationFilters_ = other.educationFilters_.Clone();
      skillFilters_ = other.skillFilters_.Clone();
      workExperienceFilter_ = other.workExperienceFilter_.Clone();
      timeFilters_ = other.timeFilters_.Clone();
      HirableFilter = other.HirableFilter;
      applicationDateFilters_ = other.applicationDateFilters_.Clone();
      applicationOutcomeReasonFilters_ = other.applicationOutcomeReasonFilters_.Clone();
      applicationLastStageFilters_ = other.applicationLastStageFilters_.Clone();
      applicationJobFilters_ = other.applicationJobFilters_.Clone();
      applicationStatusFilters_ = other.applicationStatusFilters_.Clone();
      customFieldFilter_ = other.customFieldFilter_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ProfileQuery Clone() {
      return new ProfileQuery(this);
    }

    /// <summary>Field number for the "query" field.</summary>
    public const int QueryFieldNumber = 1;
    private string query_ = "";
    /// <summary>
    /// Optional.
    ///
    /// Keywords to match any text fields of profiles.
    ///
    /// For example, "software engineer in Palo Alto".
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Query {
      get { return query_; }
      set {
        query_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "location_filters" field.</summary>
    public const int LocationFiltersFieldNumber = 2;
    private static readonly pb::FieldCodec<global::Google.Cloud.Talent.V4Beta1.LocationFilter> _repeated_locationFilters_codec
        = pb::FieldCodec.ForMessage(18, global::Google.Cloud.Talent.V4Beta1.LocationFilter.Parser);
    private readonly pbc::RepeatedField<global::Google.Cloud.Talent.V4Beta1.LocationFilter> locationFilters_ = new pbc::RepeatedField<global::Google.Cloud.Talent.V4Beta1.LocationFilter>();
    /// <summary>
    /// Optional.
    ///
    /// The location filter specifies geo-regions containing the profiles to
    /// search against.
    ///
    /// If a location filter isn't specified, profiles fitting the other search
    /// criteria are retrieved regardless of where they're located.
    ///
    /// If [LocationFilter.negated][google.cloud.talent.v4beta1.LocationFilter.negated] is specified, the result doesn't contain
    /// profiles from that location.
    ///
    /// For example, search for profiles with addresses in "New York City".
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Google.Cloud.Talent.V4Beta1.LocationFilter> LocationFilters {
      get { return locationFilters_; }
    }

    /// <summary>Field number for the "job_title_filters" field.</summary>
    public const int JobTitleFiltersFieldNumber = 3;
    private static readonly pb::FieldCodec<global::Google.Cloud.Talent.V4Beta1.JobTitleFilter> _repeated_jobTitleFilters_codec
        = pb::FieldCodec.ForMessage(26, global::Google.Cloud.Talent.V4Beta1.JobTitleFilter.Parser);
    private readonly pbc::RepeatedField<global::Google.Cloud.Talent.V4Beta1.JobTitleFilter> jobTitleFilters_ = new pbc::RepeatedField<global::Google.Cloud.Talent.V4Beta1.JobTitleFilter>();
    /// <summary>
    /// Optional.
    ///
    /// Job title filter specifies job titles of profiles to match on.
    ///
    /// If a job title isn't specified, profiles with any titles are retrieved.
    ///
    /// If multiple values are specified, profiles are retrieved with any of the
    /// specified job titles.
    ///
    /// If [JobTitleFilter.negated][google.cloud.talent.v4beta1.JobTitleFilter.negated] is specified, the result won't contain
    /// profiles with the job titles.
    ///
    /// For example, search for profiles with a job title "Product Manager".
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Google.Cloud.Talent.V4Beta1.JobTitleFilter> JobTitleFilters {
      get { return jobTitleFilters_; }
    }

    /// <summary>Field number for the "employer_filters" field.</summary>
    public const int EmployerFiltersFieldNumber = 4;
    private static readonly pb::FieldCodec<global::Google.Cloud.Talent.V4Beta1.EmployerFilter> _repeated_employerFilters_codec
        = pb::FieldCodec.ForMessage(34, global::Google.Cloud.Talent.V4Beta1.EmployerFilter.Parser);
    private readonly pbc::RepeatedField<global::Google.Cloud.Talent.V4Beta1.EmployerFilter> employerFilters_ = new pbc::RepeatedField<global::Google.Cloud.Talent.V4Beta1.EmployerFilter>();
    /// <summary>
    /// Optional.
    ///
    /// Employer filter specifies employers of profiles to match on.
    ///
    /// If an employer filter isn't specified, profiles with any employers are
    /// retrieved.
    ///
    /// If multiple employer filters are specified, profiles with any matching
    /// employers are retrieved.
    ///
    /// If [EmployerFilter.negated][google.cloud.talent.v4beta1.EmployerFilter.negated] is specified, the result won't contain
    /// profiles that match the employers.
    ///
    /// For example, search for profiles that have working experience at "Google
    /// LLC".
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Google.Cloud.Talent.V4Beta1.EmployerFilter> EmployerFilters {
      get { return employerFilters_; }
    }

    /// <summary>Field number for the "education_filters" field.</summary>
    public const int EducationFiltersFieldNumber = 5;
    private static readonly pb::FieldCodec<global::Google.Cloud.Talent.V4Beta1.EducationFilter> _repeated_educationFilters_codec
        = pb::FieldCodec.ForMessage(42, global::Google.Cloud.Talent.V4Beta1.EducationFilter.Parser);
    private readonly pbc::RepeatedField<global::Google.Cloud.Talent.V4Beta1.EducationFilter> educationFilters_ = new pbc::RepeatedField<global::Google.Cloud.Talent.V4Beta1.EducationFilter>();
    /// <summary>
    /// Optional.
    ///
    /// Education filter specifies education of profiles to match on.
    ///
    /// If an education filter isn't specified, profiles with any education are
    /// retrieved.
    ///
    /// If multiple education filters are specified, profiles that match any
    /// education filters are retrieved.
    ///
    /// If [EducationFilter.negated][google.cloud.talent.v4beta1.EducationFilter.negated] is specified, the result won't contain
    /// profiles that match the educations.
    ///
    /// For example, search for profiles with a master degree.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Google.Cloud.Talent.V4Beta1.EducationFilter> EducationFilters {
      get { return educationFilters_; }
    }

    /// <summary>Field number for the "skill_filters" field.</summary>
    public const int SkillFiltersFieldNumber = 6;
    private static readonly pb::FieldCodec<global::Google.Cloud.Talent.V4Beta1.SkillFilter> _repeated_skillFilters_codec
        = pb::FieldCodec.ForMessage(50, global::Google.Cloud.Talent.V4Beta1.SkillFilter.Parser);
    private readonly pbc::RepeatedField<global::Google.Cloud.Talent.V4Beta1.SkillFilter> skillFilters_ = new pbc::RepeatedField<global::Google.Cloud.Talent.V4Beta1.SkillFilter>();
    /// <summary>
    /// Optional.
    ///
    /// Skill filter specifies skill of profiles to match on.
    ///
    /// If a skill filter isn't specified, profiles with any skills are retrieved.
    ///
    /// If multiple skill filters are specified, profiles that match any skill
    /// filters are retrieved.
    ///
    /// If [SkillFilter.negated][google.cloud.talent.v4beta1.SkillFilter.negated] is specified, the result won't contain profiles
    /// that match the skills.
    ///
    /// For example, search for profiles that have "Java" and "Python" in skill
    /// list.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Google.Cloud.Talent.V4Beta1.SkillFilter> SkillFilters {
      get { return skillFilters_; }
    }

    /// <summary>Field number for the "work_experience_filter" field.</summary>
    public const int WorkExperienceFilterFieldNumber = 7;
    private static readonly pb::FieldCodec<global::Google.Cloud.Talent.V4Beta1.WorkExperienceFilter> _repeated_workExperienceFilter_codec
        = pb::FieldCodec.ForMessage(58, global::Google.Cloud.Talent.V4Beta1.WorkExperienceFilter.Parser);
    private readonly pbc::RepeatedField<global::Google.Cloud.Talent.V4Beta1.WorkExperienceFilter> workExperienceFilter_ = new pbc::RepeatedField<global::Google.Cloud.Talent.V4Beta1.WorkExperienceFilter>();
    /// <summary>
    /// Optional.
    ///
    /// Work experience filter specifies the total working experience of profiles
    /// to match on.
    ///
    /// If a work experience filter isn't specified, profiles with any
    /// professional experience are retrieved.
    ///
    /// If multiple work experience filters are specified, profiles that match any
    /// work experience filters are retrieved.
    ///
    /// For example, search for profiles with 10 years of work experience.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Google.Cloud.Talent.V4Beta1.WorkExperienceFilter> WorkExperienceFilter {
      get { return workExperienceFilter_; }
    }

    /// <summary>Field number for the "time_filters" field.</summary>
    public const int TimeFiltersFieldNumber = 8;
    private static readonly pb::FieldCodec<global::Google.Cloud.Talent.V4Beta1.TimeFilter> _repeated_timeFilters_codec
        = pb::FieldCodec.ForMessage(66, global::Google.Cloud.Talent.V4Beta1.TimeFilter.Parser);
    private readonly pbc::RepeatedField<global::Google.Cloud.Talent.V4Beta1.TimeFilter> timeFilters_ = new pbc::RepeatedField<global::Google.Cloud.Talent.V4Beta1.TimeFilter>();
    /// <summary>
    /// Optional.
    ///
    /// Time filter specifies the create/update timestamp of the profiles to match
    /// on.
    ///
    /// For example, search for profiles created since "2018-1-1".
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Google.Cloud.Talent.V4Beta1.TimeFilter> TimeFilters {
      get { return timeFilters_; }
    }

    /// <summary>Field number for the "hirable_filter" field.</summary>
    public const int HirableFilterFieldNumber = 9;
    private static readonly pb::FieldCodec<bool?> _single_hirableFilter_codec = pb::FieldCodec.ForStructWrapper<bool>(74);
    private bool? hirableFilter_;
    /// <summary>
    /// Optional.
    ///
    /// The hirable filter specifies the profile's hirable status to match on.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool? HirableFilter {
      get { return hirableFilter_; }
      set {
        hirableFilter_ = value;
      }
    }

    /// <summary>Field number for the "application_date_filters" field.</summary>
    public const int ApplicationDateFiltersFieldNumber = 10;
    private static readonly pb::FieldCodec<global::Google.Cloud.Talent.V4Beta1.ApplicationDateFilter> _repeated_applicationDateFilters_codec
        = pb::FieldCodec.ForMessage(82, global::Google.Cloud.Talent.V4Beta1.ApplicationDateFilter.Parser);
    private readonly pbc::RepeatedField<global::Google.Cloud.Talent.V4Beta1.ApplicationDateFilter> applicationDateFilters_ = new pbc::RepeatedField<global::Google.Cloud.Talent.V4Beta1.ApplicationDateFilter>();
    /// <summary>
    /// Optional.
    ///
    /// The application date filters specify application date ranges to match on.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Google.Cloud.Talent.V4Beta1.ApplicationDateFilter> ApplicationDateFilters {
      get { return applicationDateFilters_; }
    }

    /// <summary>Field number for the "application_outcome_reason_filters" field.</summary>
    public const int ApplicationOutcomeReasonFiltersFieldNumber = 11;
    private static readonly pb::FieldCodec<global::Google.Cloud.Talent.V4Beta1.ApplicationOutcomeReasonFilter> _repeated_applicationOutcomeReasonFilters_codec
        = pb::FieldCodec.ForMessage(90, global::Google.Cloud.Talent.V4Beta1.ApplicationOutcomeReasonFilter.Parser);
    private readonly pbc::RepeatedField<global::Google.Cloud.Talent.V4Beta1.ApplicationOutcomeReasonFilter> applicationOutcomeReasonFilters_ = new pbc::RepeatedField<global::Google.Cloud.Talent.V4Beta1.ApplicationOutcomeReasonFilter>();
    /// <summary>
    /// Optional.
    ///
    /// The application outcome reason filters specify the reasons for outcome of
    /// the job application.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Google.Cloud.Talent.V4Beta1.ApplicationOutcomeReasonFilter> ApplicationOutcomeReasonFilters {
      get { return applicationOutcomeReasonFilters_; }
    }

    /// <summary>Field number for the "application_last_stage_filters" field.</summary>
    public const int ApplicationLastStageFiltersFieldNumber = 12;
    private static readonly pb::FieldCodec<global::Google.Cloud.Talent.V4Beta1.ApplicationLastStageFilter> _repeated_applicationLastStageFilters_codec
        = pb::FieldCodec.ForMessage(98, global::Google.Cloud.Talent.V4Beta1.ApplicationLastStageFilter.Parser);
    private readonly pbc::RepeatedField<global::Google.Cloud.Talent.V4Beta1.ApplicationLastStageFilter> applicationLastStageFilters_ = new pbc::RepeatedField<global::Google.Cloud.Talent.V4Beta1.ApplicationLastStageFilter>();
    /// <summary>
    /// Optional.
    ///
    /// The application last stage filters specify the last stage of job
    /// application.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Google.Cloud.Talent.V4Beta1.ApplicationLastStageFilter> ApplicationLastStageFilters {
      get { return applicationLastStageFilters_; }
    }

    /// <summary>Field number for the "application_job_filters" field.</summary>
    public const int ApplicationJobFiltersFieldNumber = 13;
    private static readonly pb::FieldCodec<global::Google.Cloud.Talent.V4Beta1.ApplicationJobFilter> _repeated_applicationJobFilters_codec
        = pb::FieldCodec.ForMessage(106, global::Google.Cloud.Talent.V4Beta1.ApplicationJobFilter.Parser);
    private readonly pbc::RepeatedField<global::Google.Cloud.Talent.V4Beta1.ApplicationJobFilter> applicationJobFilters_ = new pbc::RepeatedField<global::Google.Cloud.Talent.V4Beta1.ApplicationJobFilter>();
    /// <summary>
    /// Optional.
    ///
    /// The application job filters specify the job applied for in the application.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Google.Cloud.Talent.V4Beta1.ApplicationJobFilter> ApplicationJobFilters {
      get { return applicationJobFilters_; }
    }

    /// <summary>Field number for the "application_status_filters" field.</summary>
    public const int ApplicationStatusFiltersFieldNumber = 14;
    private static readonly pb::FieldCodec<global::Google.Cloud.Talent.V4Beta1.ApplicationStatusFilter> _repeated_applicationStatusFilters_codec
        = pb::FieldCodec.ForMessage(114, global::Google.Cloud.Talent.V4Beta1.ApplicationStatusFilter.Parser);
    private readonly pbc::RepeatedField<global::Google.Cloud.Talent.V4Beta1.ApplicationStatusFilter> applicationStatusFilters_ = new pbc::RepeatedField<global::Google.Cloud.Talent.V4Beta1.ApplicationStatusFilter>();
    /// <summary>
    /// Optional.
    ///
    /// The application status filters specify the status of job application.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Google.Cloud.Talent.V4Beta1.ApplicationStatusFilter> ApplicationStatusFilters {
      get { return applicationStatusFilters_; }
    }

    /// <summary>Field number for the "custom_field_filter" field.</summary>
    public const int CustomFieldFilterFieldNumber = 15;
    private string customFieldFilter_ = "";
    /// <summary>
    /// Optional.
    ///
    /// This filter specifies a structured syntax to match against the
    /// [Profile.custom_attributes][google.cloud.talent.v4beta1.Profile.custom_attributes] that are marked as `filterable`.
    ///
    /// The syntax for this expression is a subset of Google SQL syntax.
    ///
    /// Supported operators are: =, != where the left of the operator is a custom
    /// field key and the right of the operator is a string (surrounded by quotes)
    /// value.
    ///
    /// Supported functions are LOWER(&lt;field_name>) to
    /// perform case insensitive match and EMPTY(&lt;field_name>) to filter on the
    /// existence of a key.
    ///
    /// Boolean expressions (AND/OR/NOT) are supported up to 3 levels of
    /// nesting (for example "((A AND B AND C) OR NOT D) AND E"), and there can be
    /// a maximum of 50 comparisons/functions in the expression. The expression
    /// must be &lt; 2000 characters in length.
    ///
    /// Sample Query:
    /// (key1 = "TEST" OR LOWER(key1)="test" OR NOT EMPTY(key1))
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string CustomFieldFilter {
      get { return customFieldFilter_; }
      set {
        customFieldFilter_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as ProfileQuery);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(ProfileQuery other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Query != other.Query) return false;
      if(!locationFilters_.Equals(other.locationFilters_)) return false;
      if(!jobTitleFilters_.Equals(other.jobTitleFilters_)) return false;
      if(!employerFilters_.Equals(other.employerFilters_)) return false;
      if(!educationFilters_.Equals(other.educationFilters_)) return false;
      if(!skillFilters_.Equals(other.skillFilters_)) return false;
      if(!workExperienceFilter_.Equals(other.workExperienceFilter_)) return false;
      if(!timeFilters_.Equals(other.timeFilters_)) return false;
      if (HirableFilter != other.HirableFilter) return false;
      if(!applicationDateFilters_.Equals(other.applicationDateFilters_)) return false;
      if(!applicationOutcomeReasonFilters_.Equals(other.applicationOutcomeReasonFilters_)) return false;
      if(!applicationLastStageFilters_.Equals(other.applicationLastStageFilters_)) return false;
      if(!applicationJobFilters_.Equals(other.applicationJobFilters_)) return false;
      if(!applicationStatusFilters_.Equals(other.applicationStatusFilters_)) return false;
      if (CustomFieldFilter != other.CustomFieldFilter) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Query.Length != 0) hash ^= Query.GetHashCode();
      hash ^= locationFilters_.GetHashCode();
      hash ^= jobTitleFilters_.GetHashCode();
      hash ^= employerFilters_.GetHashCode();
      hash ^= educationFilters_.GetHashCode();
      hash ^= skillFilters_.GetHashCode();
      hash ^= workExperienceFilter_.GetHashCode();
      hash ^= timeFilters_.GetHashCode();
      if (hirableFilter_ != null) hash ^= HirableFilter.GetHashCode();
      hash ^= applicationDateFilters_.GetHashCode();
      hash ^= applicationOutcomeReasonFilters_.GetHashCode();
      hash ^= applicationLastStageFilters_.GetHashCode();
      hash ^= applicationJobFilters_.GetHashCode();
      hash ^= applicationStatusFilters_.GetHashCode();
      if (CustomFieldFilter.Length != 0) hash ^= CustomFieldFilter.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (Query.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Query);
      }
      locationFilters_.WriteTo(output, _repeated_locationFilters_codec);
      jobTitleFilters_.WriteTo(output, _repeated_jobTitleFilters_codec);
      employerFilters_.WriteTo(output, _repeated_employerFilters_codec);
      educationFilters_.WriteTo(output, _repeated_educationFilters_codec);
      skillFilters_.WriteTo(output, _repeated_skillFilters_codec);
      workExperienceFilter_.WriteTo(output, _repeated_workExperienceFilter_codec);
      timeFilters_.WriteTo(output, _repeated_timeFilters_codec);
      if (hirableFilter_ != null) {
        _single_hirableFilter_codec.WriteTagAndValue(output, HirableFilter);
      }
      applicationDateFilters_.WriteTo(output, _repeated_applicationDateFilters_codec);
      applicationOutcomeReasonFilters_.WriteTo(output, _repeated_applicationOutcomeReasonFilters_codec);
      applicationLastStageFilters_.WriteTo(output, _repeated_applicationLastStageFilters_codec);
      applicationJobFilters_.WriteTo(output, _repeated_applicationJobFilters_codec);
      applicationStatusFilters_.WriteTo(output, _repeated_applicationStatusFilters_codec);
      if (CustomFieldFilter.Length != 0) {
        output.WriteRawTag(122);
        output.WriteString(CustomFieldFilter);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Query.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Query);
      }
      size += locationFilters_.CalculateSize(_repeated_locationFilters_codec);
      size += jobTitleFilters_.CalculateSize(_repeated_jobTitleFilters_codec);
      size += employerFilters_.CalculateSize(_repeated_employerFilters_codec);
      size += educationFilters_.CalculateSize(_repeated_educationFilters_codec);
      size += skillFilters_.CalculateSize(_repeated_skillFilters_codec);
      size += workExperienceFilter_.CalculateSize(_repeated_workExperienceFilter_codec);
      size += timeFilters_.CalculateSize(_repeated_timeFilters_codec);
      if (hirableFilter_ != null) {
        size += _single_hirableFilter_codec.CalculateSizeWithTag(HirableFilter);
      }
      size += applicationDateFilters_.CalculateSize(_repeated_applicationDateFilters_codec);
      size += applicationOutcomeReasonFilters_.CalculateSize(_repeated_applicationOutcomeReasonFilters_codec);
      size += applicationLastStageFilters_.CalculateSize(_repeated_applicationLastStageFilters_codec);
      size += applicationJobFilters_.CalculateSize(_repeated_applicationJobFilters_codec);
      size += applicationStatusFilters_.CalculateSize(_repeated_applicationStatusFilters_codec);
      if (CustomFieldFilter.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(CustomFieldFilter);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(ProfileQuery other) {
      if (other == null) {
        return;
      }
      if (other.Query.Length != 0) {
        Query = other.Query;
      }
      locationFilters_.Add(other.locationFilters_);
      jobTitleFilters_.Add(other.jobTitleFilters_);
      employerFilters_.Add(other.employerFilters_);
      educationFilters_.Add(other.educationFilters_);
      skillFilters_.Add(other.skillFilters_);
      workExperienceFilter_.Add(other.workExperienceFilter_);
      timeFilters_.Add(other.timeFilters_);
      if (other.hirableFilter_ != null) {
        if (hirableFilter_ == null || other.HirableFilter != false) {
          HirableFilter = other.HirableFilter;
        }
      }
      applicationDateFilters_.Add(other.applicationDateFilters_);
      applicationOutcomeReasonFilters_.Add(other.applicationOutcomeReasonFilters_);
      applicationLastStageFilters_.Add(other.applicationLastStageFilters_);
      applicationJobFilters_.Add(other.applicationJobFilters_);
      applicationStatusFilters_.Add(other.applicationStatusFilters_);
      if (other.CustomFieldFilter.Length != 0) {
        CustomFieldFilter = other.CustomFieldFilter;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Query = input.ReadString();
            break;
          }
          case 18: {
            locationFilters_.AddEntriesFrom(input, _repeated_locationFilters_codec);
            break;
          }
          case 26: {
            jobTitleFilters_.AddEntriesFrom(input, _repeated_jobTitleFilters_codec);
            break;
          }
          case 34: {
            employerFilters_.AddEntriesFrom(input, _repeated_employerFilters_codec);
            break;
          }
          case 42: {
            educationFilters_.AddEntriesFrom(input, _repeated_educationFilters_codec);
            break;
          }
          case 50: {
            skillFilters_.AddEntriesFrom(input, _repeated_skillFilters_codec);
            break;
          }
          case 58: {
            workExperienceFilter_.AddEntriesFrom(input, _repeated_workExperienceFilter_codec);
            break;
          }
          case 66: {
            timeFilters_.AddEntriesFrom(input, _repeated_timeFilters_codec);
            break;
          }
          case 74: {
            bool? value = _single_hirableFilter_codec.Read(input);
            if (hirableFilter_ == null || value != false) {
              HirableFilter = value;
            }
            break;
          }
          case 82: {
            applicationDateFilters_.AddEntriesFrom(input, _repeated_applicationDateFilters_codec);
            break;
          }
          case 90: {
            applicationOutcomeReasonFilters_.AddEntriesFrom(input, _repeated_applicationOutcomeReasonFilters_codec);
            break;
          }
          case 98: {
            applicationLastStageFilters_.AddEntriesFrom(input, _repeated_applicationLastStageFilters_codec);
            break;
          }
          case 106: {
            applicationJobFilters_.AddEntriesFrom(input, _repeated_applicationJobFilters_codec);
            break;
          }
          case 114: {
            applicationStatusFilters_.AddEntriesFrom(input, _repeated_applicationStatusFilters_codec);
            break;
          }
          case 122: {
            CustomFieldFilter = input.ReadString();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// Input only.
  ///
  /// Geographic region of the search.
  /// </summary>
  public sealed partial class LocationFilter : pb::IMessage<LocationFilter> {
    private static readonly pb::MessageParser<LocationFilter> _parser = new pb::MessageParser<LocationFilter>(() => new LocationFilter());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<LocationFilter> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Cloud.Talent.V4Beta1.FiltersReflection.Descriptor.MessageTypes[2]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public LocationFilter() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public LocationFilter(LocationFilter other) : this() {
      address_ = other.address_;
      regionCode_ = other.regionCode_;
      latLng_ = other.latLng_ != null ? other.latLng_.Clone() : null;
      distanceInMiles_ = other.distanceInMiles_;
      telecommutePreference_ = other.telecommutePreference_;
      negated_ = other.negated_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public LocationFilter Clone() {
      return new LocationFilter(this);
    }

    /// <summary>Field number for the "address" field.</summary>
    public const int AddressFieldNumber = 1;
    private string address_ = "";
    /// <summary>
    /// Optional.
    ///
    /// The address name, such as "Mountain View" or "Bay Area".
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Address {
      get { return address_; }
      set {
        address_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "region_code" field.</summary>
    public const int RegionCodeFieldNumber = 2;
    private string regionCode_ = "";
    /// <summary>
    /// Optional.
    ///
    /// CLDR region code of the country/region of the address. This is used
    /// to address ambiguity of the user-input location, for example, "Liverpool"
    /// against "Liverpool, NY, US" or "Liverpool, UK".
    ///
    /// Set this field if all the jobs to search against are from a same region,
    /// or jobs are world-wide, but the job seeker is from a specific region.
    ///
    /// See http://cldr.unicode.org/ and
    /// http://www.unicode.org/cldr/charts/30/supplemental/territory_information.html
    /// for details. Example: "CH" for Switzerland.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string RegionCode {
      get { return regionCode_; }
      set {
        regionCode_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "lat_lng" field.</summary>
    public const int LatLngFieldNumber = 3;
    private global::Google.Type.LatLng latLng_;
    /// <summary>
    /// Optional.
    ///
    /// The latitude and longitude of the geographic center from which to
    /// search. This field's ignored if `address` is provided.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Type.LatLng LatLng {
      get { return latLng_; }
      set {
        latLng_ = value;
      }
    }

    /// <summary>Field number for the "distance_in_miles" field.</summary>
    public const int DistanceInMilesFieldNumber = 4;
    private double distanceInMiles_;
    /// <summary>
    /// Optional.
    ///
    /// The distance_in_miles is applied when the location being searched for is
    /// identified as a city or smaller. When the location being searched for is a
    /// state or larger, this field is ignored.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public double DistanceInMiles {
      get { return distanceInMiles_; }
      set {
        distanceInMiles_ = value;
      }
    }

    /// <summary>Field number for the "telecommute_preference" field.</summary>
    public const int TelecommutePreferenceFieldNumber = 5;
    private global::Google.Cloud.Talent.V4Beta1.LocationFilter.Types.TelecommutePreference telecommutePreference_ = 0;
    /// <summary>
    /// Optional.
    ///
    /// Allows the client to return jobs without a
    /// set location, specifically, telecommuting jobs (telecomuting is considered
    /// by the service as a special location.
    /// [Job.posting_region][google.cloud.talent.v4beta1.Job.posting_region] indicates if a job permits telecommuting.
    /// If this field is set to [TelecommutePreference.TELECOMMUTE_ALLOWED][google.cloud.talent.v4beta1.LocationFilter.TelecommutePreference.TELECOMMUTE_ALLOWED],
    /// telecommuting jobs are searched, and [address][google.cloud.talent.v4beta1.LocationFilter.address] and [lat_lng][google.cloud.talent.v4beta1.LocationFilter.lat_lng] are
    /// ignored. If not set or set to
    /// [TelecommutePreference.TELECOMMUTE_EXCLUDED][google.cloud.talent.v4beta1.LocationFilter.TelecommutePreference.TELECOMMUTE_EXCLUDED], telecommute job are not
    /// searched.
    ///
    /// This filter can be used by itself to search exclusively for telecommuting
    /// jobs, or it can be combined with another location
    /// filter to search for a combination of job locations,
    /// such as "Mountain View" or "telecommuting" jobs. However, when used in
    /// combination with other location filters, telecommuting jobs can be
    /// treated as less relevant than other jobs in the search response.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Cloud.Talent.V4Beta1.LocationFilter.Types.TelecommutePreference TelecommutePreference {
      get { return telecommutePreference_; }
      set {
        telecommutePreference_ = value;
      }
    }

    /// <summary>Field number for the "negated" field.</summary>
    public const int NegatedFieldNumber = 6;
    private bool negated_;
    /// <summary>
    /// Optional.
    ///
    /// Whether to apply negation to the filter so profiles matching the filter
    /// are excluded.
    ///
    /// Currently only supported in profile search.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Negated {
      get { return negated_; }
      set {
        negated_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as LocationFilter);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(LocationFilter other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Address != other.Address) return false;
      if (RegionCode != other.RegionCode) return false;
      if (!object.Equals(LatLng, other.LatLng)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.Equals(DistanceInMiles, other.DistanceInMiles)) return false;
      if (TelecommutePreference != other.TelecommutePreference) return false;
      if (Negated != other.Negated) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Address.Length != 0) hash ^= Address.GetHashCode();
      if (RegionCode.Length != 0) hash ^= RegionCode.GetHashCode();
      if (latLng_ != null) hash ^= LatLng.GetHashCode();
      if (DistanceInMiles != 0D) hash ^= pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.GetHashCode(DistanceInMiles);
      if (TelecommutePreference != 0) hash ^= TelecommutePreference.GetHashCode();
      if (Negated != false) hash ^= Negated.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (Address.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Address);
      }
      if (RegionCode.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(RegionCode);
      }
      if (latLng_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(LatLng);
      }
      if (DistanceInMiles != 0D) {
        output.WriteRawTag(33);
        output.WriteDouble(DistanceInMiles);
      }
      if (TelecommutePreference != 0) {
        output.WriteRawTag(40);
        output.WriteEnum((int) TelecommutePreference);
      }
      if (Negated != false) {
        output.WriteRawTag(48);
        output.WriteBool(Negated);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Address.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Address);
      }
      if (RegionCode.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(RegionCode);
      }
      if (latLng_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(LatLng);
      }
      if (DistanceInMiles != 0D) {
        size += 1 + 8;
      }
      if (TelecommutePreference != 0) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) TelecommutePreference);
      }
      if (Negated != false) {
        size += 1 + 1;
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(LocationFilter other) {
      if (other == null) {
        return;
      }
      if (other.Address.Length != 0) {
        Address = other.Address;
      }
      if (other.RegionCode.Length != 0) {
        RegionCode = other.RegionCode;
      }
      if (other.latLng_ != null) {
        if (latLng_ == null) {
          latLng_ = new global::Google.Type.LatLng();
        }
        LatLng.MergeFrom(other.LatLng);
      }
      if (other.DistanceInMiles != 0D) {
        DistanceInMiles = other.DistanceInMiles;
      }
      if (other.TelecommutePreference != 0) {
        TelecommutePreference = other.TelecommutePreference;
      }
      if (other.Negated != false) {
        Negated = other.Negated;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Address = input.ReadString();
            break;
          }
          case 18: {
            RegionCode = input.ReadString();
            break;
          }
          case 26: {
            if (latLng_ == null) {
              latLng_ = new global::Google.Type.LatLng();
            }
            input.ReadMessage(latLng_);
            break;
          }
          case 33: {
            DistanceInMiles = input.ReadDouble();
            break;
          }
          case 40: {
            telecommutePreference_ = (global::Google.Cloud.Talent.V4Beta1.LocationFilter.Types.TelecommutePreference) input.ReadEnum();
            break;
          }
          case 48: {
            Negated = input.ReadBool();
            break;
          }
        }
      }
    }

    #region Nested types
    /// <summary>Container for nested types declared in the LocationFilter message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      /// <summary>
      /// Specify whether including telecommute jobs.
      /// </summary>
      public enum TelecommutePreference {
        /// <summary>
        /// Default value if the telecommute preference isn't specified.
        /// </summary>
        [pbr::OriginalName("TELECOMMUTE_PREFERENCE_UNSPECIFIED")] Unspecified = 0,
        /// <summary>
        /// Exclude telecommute jobs.
        /// </summary>
        [pbr::OriginalName("TELECOMMUTE_EXCLUDED")] TelecommuteExcluded = 1,
        /// <summary>
        /// Allow telecommute jobs.
        /// </summary>
        [pbr::OriginalName("TELECOMMUTE_ALLOWED")] TelecommuteAllowed = 2,
      }

    }
    #endregion

  }

  /// <summary>
  /// Input only.
  ///
  /// Filter on job compensation type and amount.
  /// </summary>
  public sealed partial class CompensationFilter : pb::IMessage<CompensationFilter> {
    private static readonly pb::MessageParser<CompensationFilter> _parser = new pb::MessageParser<CompensationFilter>(() => new CompensationFilter());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<CompensationFilter> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Cloud.Talent.V4Beta1.FiltersReflection.Descriptor.MessageTypes[3]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public CompensationFilter() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public CompensationFilter(CompensationFilter other) : this() {
      type_ = other.type_;
      units_ = other.units_.Clone();
      range_ = other.range_ != null ? other.range_.Clone() : null;
      includeJobsWithUnspecifiedCompensationRange_ = other.includeJobsWithUnspecifiedCompensationRange_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public CompensationFilter Clone() {
      return new CompensationFilter(this);
    }

    /// <summary>Field number for the "type" field.</summary>
    public const int TypeFieldNumber = 1;
    private global::Google.Cloud.Talent.V4Beta1.CompensationFilter.Types.FilterType type_ = 0;
    /// <summary>
    /// Required.
    ///
    /// Type of filter.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Cloud.Talent.V4Beta1.CompensationFilter.Types.FilterType Type {
      get { return type_; }
      set {
        type_ = value;
      }
    }

    /// <summary>Field number for the "units" field.</summary>
    public const int UnitsFieldNumber = 2;
    private static readonly pb::FieldCodec<global::Google.Cloud.Talent.V4Beta1.CompensationInfo.Types.CompensationUnit> _repeated_units_codec
        = pb::FieldCodec.ForEnum(18, x => (int) x, x => (global::Google.Cloud.Talent.V4Beta1.CompensationInfo.Types.CompensationUnit) x);
    private readonly pbc::RepeatedField<global::Google.Cloud.Talent.V4Beta1.CompensationInfo.Types.CompensationUnit> units_ = new pbc::RepeatedField<global::Google.Cloud.Talent.V4Beta1.CompensationInfo.Types.CompensationUnit>();
    /// <summary>
    /// Required.
    ///
    /// Specify desired `base compensation entry's`
    /// [CompensationInfo.CompensationUnit][google.cloud.talent.v4beta1.CompensationInfo.CompensationUnit].
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Google.Cloud.Talent.V4Beta1.CompensationInfo.Types.CompensationUnit> Units {
      get { return units_; }
    }

    /// <summary>Field number for the "range" field.</summary>
    public const int RangeFieldNumber = 3;
    private global::Google.Cloud.Talent.V4Beta1.CompensationInfo.Types.CompensationRange range_;
    /// <summary>
    /// Optional.
    ///
    /// Compensation range.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Cloud.Talent.V4Beta1.CompensationInfo.Types.CompensationRange Range {
      get { return range_; }
      set {
        range_ = value;
      }
    }

    /// <summary>Field number for the "include_jobs_with_unspecified_compensation_range" field.</summary>
    public const int IncludeJobsWithUnspecifiedCompensationRangeFieldNumber = 4;
    private bool includeJobsWithUnspecifiedCompensationRange_;
    /// <summary>
    /// Optional.
    ///
    /// Whether to include jobs whose compensation range is unspecified.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IncludeJobsWithUnspecifiedCompensationRange {
      get { return includeJobsWithUnspecifiedCompensationRange_; }
      set {
        includeJobsWithUnspecifiedCompensationRange_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as CompensationFilter);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(CompensationFilter other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Type != other.Type) return false;
      if(!units_.Equals(other.units_)) return false;
      if (!object.Equals(Range, other.Range)) return false;
      if (IncludeJobsWithUnspecifiedCompensationRange != other.IncludeJobsWithUnspecifiedCompensationRange) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Type != 0) hash ^= Type.GetHashCode();
      hash ^= units_.GetHashCode();
      if (range_ != null) hash ^= Range.GetHashCode();
      if (IncludeJobsWithUnspecifiedCompensationRange != false) hash ^= IncludeJobsWithUnspecifiedCompensationRange.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (Type != 0) {
        output.WriteRawTag(8);
        output.WriteEnum((int) Type);
      }
      units_.WriteTo(output, _repeated_units_codec);
      if (range_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(Range);
      }
      if (IncludeJobsWithUnspecifiedCompensationRange != false) {
        output.WriteRawTag(32);
        output.WriteBool(IncludeJobsWithUnspecifiedCompensationRange);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Type != 0) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Type);
      }
      size += units_.CalculateSize(_repeated_units_codec);
      if (range_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Range);
      }
      if (IncludeJobsWithUnspecifiedCompensationRange != false) {
        size += 1 + 1;
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(CompensationFilter other) {
      if (other == null) {
        return;
      }
      if (other.Type != 0) {
        Type = other.Type;
      }
      units_.Add(other.units_);
      if (other.range_ != null) {
        if (range_ == null) {
          range_ = new global::Google.Cloud.Talent.V4Beta1.CompensationInfo.Types.CompensationRange();
        }
        Range.MergeFrom(other.Range);
      }
      if (other.IncludeJobsWithUnspecifiedCompensationRange != false) {
        IncludeJobsWithUnspecifiedCompensationRange = other.IncludeJobsWithUnspecifiedCompensationRange;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            type_ = (global::Google.Cloud.Talent.V4Beta1.CompensationFilter.Types.FilterType) input.ReadEnum();
            break;
          }
          case 18:
          case 16: {
            units_.AddEntriesFrom(input, _repeated_units_codec);
            break;
          }
          case 26: {
            if (range_ == null) {
              range_ = new global::Google.Cloud.Talent.V4Beta1.CompensationInfo.Types.CompensationRange();
            }
            input.ReadMessage(range_);
            break;
          }
          case 32: {
            IncludeJobsWithUnspecifiedCompensationRange = input.ReadBool();
            break;
          }
        }
      }
    }

    #region Nested types
    /// <summary>Container for nested types declared in the CompensationFilter message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      /// <summary>
      /// Specify the type of filtering.
      /// </summary>
      public enum FilterType {
        /// <summary>
        /// Filter type unspecified. Position holder, INVALID, should never be used.
        /// </summary>
        [pbr::OriginalName("FILTER_TYPE_UNSPECIFIED")] Unspecified = 0,
        /// <summary>
        /// Filter by `base compensation entry's` unit. A job is a match if and
        /// only if the job contains a base CompensationEntry and the base
        /// CompensationEntry's unit matches provided [units][google.cloud.talent.v4beta1.CompensationFilter.units].
        /// Populate one or more [units][google.cloud.talent.v4beta1.CompensationFilter.units].
        ///
        /// See [CompensationInfo.CompensationEntry][google.cloud.talent.v4beta1.CompensationInfo.CompensationEntry] for definition of
        /// base compensation entry.
        /// </summary>
        [pbr::OriginalName("UNIT_ONLY")] UnitOnly = 1,
        /// <summary>
        /// Filter by `base compensation entry's` unit and amount / range. A job
        /// is a match if and only if the job contains a base CompensationEntry, and
        /// the base entry's unit matches provided [compensation_units][] and amount
        /// or range overlaps with provided [compensation_range][].
        ///
        /// See [CompensationInfo.CompensationEntry][google.cloud.talent.v4beta1.CompensationInfo.CompensationEntry] for definition of
        /// base compensation entry.
        ///
        /// Set exactly one [units][google.cloud.talent.v4beta1.CompensationFilter.units] and populate [range][google.cloud.talent.v4beta1.CompensationFilter.range].
        /// </summary>
        [pbr::OriginalName("UNIT_AND_AMOUNT")] UnitAndAmount = 2,
        /// <summary>
        /// Filter by annualized base compensation amount and `base compensation
        /// entry's` unit. Populate [range][google.cloud.talent.v4beta1.CompensationFilter.range] and zero or more [units][google.cloud.talent.v4beta1.CompensationFilter.units].
        /// </summary>
        [pbr::OriginalName("ANNUALIZED_BASE_AMOUNT")] AnnualizedBaseAmount = 3,
        /// <summary>
        /// Filter by annualized total compensation amount and `base compensation
        /// entry's` unit . Populate [range][google.cloud.talent.v4beta1.CompensationFilter.range] and zero or more [units][google.cloud.talent.v4beta1.CompensationFilter.units].
        /// </summary>
        [pbr::OriginalName("ANNUALIZED_TOTAL_AMOUNT")] AnnualizedTotalAmount = 4,
      }

    }
    #endregion

  }

  /// <summary>
  /// Input only.
  ///
  /// Parameters needed for commute search.
  /// </summary>
  public sealed partial class CommuteFilter : pb::IMessage<CommuteFilter> {
    private static readonly pb::MessageParser<CommuteFilter> _parser = new pb::MessageParser<CommuteFilter>(() => new CommuteFilter());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<CommuteFilter> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Cloud.Talent.V4Beta1.FiltersReflection.Descriptor.MessageTypes[4]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public CommuteFilter() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public CommuteFilter(CommuteFilter other) : this() {
      commuteMethod_ = other.commuteMethod_;
      startCoordinates_ = other.startCoordinates_ != null ? other.startCoordinates_.Clone() : null;
      travelDuration_ = other.travelDuration_ != null ? other.travelDuration_.Clone() : null;
      allowImpreciseAddresses_ = other.allowImpreciseAddresses_;
      switch (other.TrafficOptionCase) {
        case TrafficOptionOneofCase.RoadTraffic:
          RoadTraffic = other.RoadTraffic;
          break;
        case TrafficOptionOneofCase.DepartureTime:
          DepartureTime = other.DepartureTime.Clone();
          break;
      }

      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public CommuteFilter Clone() {
      return new CommuteFilter(this);
    }

    /// <summary>Field number for the "commute_method" field.</summary>
    public const int CommuteMethodFieldNumber = 1;
    private global::Google.Cloud.Talent.V4Beta1.CommuteFilter.Types.CommuteMethod commuteMethod_ = 0;
    /// <summary>
    /// Required.
    ///
    /// The method of transportation for which to calculate the commute time.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Cloud.Talent.V4Beta1.CommuteFilter.Types.CommuteMethod CommuteMethod {
      get { return commuteMethod_; }
      set {
        commuteMethod_ = value;
      }
    }

    /// <summary>Field number for the "start_coordinates" field.</summary>
    public const int StartCoordinatesFieldNumber = 2;
    private global::Google.Type.LatLng startCoordinates_;
    /// <summary>
    /// Required.
    ///
    /// The latitude and longitude of the location from which to calculate the
    /// commute time.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Type.LatLng StartCoordinates {
      get { return startCoordinates_; }
      set {
        startCoordinates_ = value;
      }
    }

    /// <summary>Field number for the "travel_duration" field.</summary>
    public const int TravelDurationFieldNumber = 3;
    private global::Google.Protobuf.WellKnownTypes.Duration travelDuration_;
    /// <summary>
    /// Required.
    ///
    /// The maximum travel time in seconds. The maximum allowed value is `3600s`
    /// (one hour). Format is `123s`.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Protobuf.WellKnownTypes.Duration TravelDuration {
      get { return travelDuration_; }
      set {
        travelDuration_ = value;
      }
    }

    /// <summary>Field number for the "allow_imprecise_addresses" field.</summary>
    public const int AllowImpreciseAddressesFieldNumber = 4;
    private bool allowImpreciseAddresses_;
    /// <summary>
    /// Optional.
    /// If `true`, jobs without street level addresses may also be returned.
    /// For city level addresses, the city center is used. For state and coarser
    /// level addresses, text matching is used.
    /// If this field is set to `false` or isn't specified, only jobs that include
    /// street level addresses will be returned by commute search.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool AllowImpreciseAddresses {
      get { return allowImpreciseAddresses_; }
      set {
        allowImpreciseAddresses_ = value;
      }
    }

    /// <summary>Field number for the "road_traffic" field.</summary>
    public const int RoadTrafficFieldNumber = 5;
    /// <summary>
    /// Optional.
    ///
    /// Specifies the traffic density to use when calculating commute time.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Cloud.Talent.V4Beta1.CommuteFilter.Types.RoadTraffic RoadTraffic {
      get { return trafficOptionCase_ == TrafficOptionOneofCase.RoadTraffic ? (global::Google.Cloud.Talent.V4Beta1.CommuteFilter.Types.RoadTraffic) trafficOption_ : 0; }
      set {
        trafficOption_ = value;
        trafficOptionCase_ = TrafficOptionOneofCase.RoadTraffic;
      }
    }

    /// <summary>Field number for the "departure_time" field.</summary>
    public const int DepartureTimeFieldNumber = 6;
    /// <summary>
    /// Optional.
    ///
    /// The departure time used to calculate traffic impact, represented as
    /// [google.type.TimeOfDay][google.type.TimeOfDay] in local time zone.
    ///
    /// Currently traffic model is restricted to hour level resolution.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Type.TimeOfDay DepartureTime {
      get { return trafficOptionCase_ == TrafficOptionOneofCase.DepartureTime ? (global::Google.Type.TimeOfDay) trafficOption_ : null; }
      set {
        trafficOption_ = value;
        trafficOptionCase_ = value == null ? TrafficOptionOneofCase.None : TrafficOptionOneofCase.DepartureTime;
      }
    }

    private object trafficOption_;
    /// <summary>Enum of possible cases for the "traffic_option" oneof.</summary>
    public enum TrafficOptionOneofCase {
      None = 0,
      RoadTraffic = 5,
      DepartureTime = 6,
    }
    private TrafficOptionOneofCase trafficOptionCase_ = TrafficOptionOneofCase.None;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TrafficOptionOneofCase TrafficOptionCase {
      get { return trafficOptionCase_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearTrafficOption() {
      trafficOptionCase_ = TrafficOptionOneofCase.None;
      trafficOption_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as CommuteFilter);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(CommuteFilter other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (CommuteMethod != other.CommuteMethod) return false;
      if (!object.Equals(StartCoordinates, other.StartCoordinates)) return false;
      if (!object.Equals(TravelDuration, other.TravelDuration)) return false;
      if (AllowImpreciseAddresses != other.AllowImpreciseAddresses) return false;
      if (RoadTraffic != other.RoadTraffic) return false;
      if (!object.Equals(DepartureTime, other.DepartureTime)) return false;
      if (TrafficOptionCase != other.TrafficOptionCase) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (CommuteMethod != 0) hash ^= CommuteMethod.GetHashCode();
      if (startCoordinates_ != null) hash ^= StartCoordinates.GetHashCode();
      if (travelDuration_ != null) hash ^= TravelDuration.GetHashCode();
      if (AllowImpreciseAddresses != false) hash ^= AllowImpreciseAddresses.GetHashCode();
      if (trafficOptionCase_ == TrafficOptionOneofCase.RoadTraffic) hash ^= RoadTraffic.GetHashCode();
      if (trafficOptionCase_ == TrafficOptionOneofCase.DepartureTime) hash ^= DepartureTime.GetHashCode();
      hash ^= (int) trafficOptionCase_;
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (CommuteMethod != 0) {
        output.WriteRawTag(8);
        output.WriteEnum((int) CommuteMethod);
      }
      if (startCoordinates_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(StartCoordinates);
      }
      if (travelDuration_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(TravelDuration);
      }
      if (AllowImpreciseAddresses != false) {
        output.WriteRawTag(32);
        output.WriteBool(AllowImpreciseAddresses);
      }
      if (trafficOptionCase_ == TrafficOptionOneofCase.RoadTraffic) {
        output.WriteRawTag(40);
        output.WriteEnum((int) RoadTraffic);
      }
      if (trafficOptionCase_ == TrafficOptionOneofCase.DepartureTime) {
        output.WriteRawTag(50);
        output.WriteMessage(DepartureTime);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (CommuteMethod != 0) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) CommuteMethod);
      }
      if (startCoordinates_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(StartCoordinates);
      }
      if (travelDuration_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(TravelDuration);
      }
      if (AllowImpreciseAddresses != false) {
        size += 1 + 1;
      }
      if (trafficOptionCase_ == TrafficOptionOneofCase.RoadTraffic) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) RoadTraffic);
      }
      if (trafficOptionCase_ == TrafficOptionOneofCase.DepartureTime) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(DepartureTime);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(CommuteFilter other) {
      if (other == null) {
        return;
      }
      if (other.CommuteMethod != 0) {
        CommuteMethod = other.CommuteMethod;
      }
      if (other.startCoordinates_ != null) {
        if (startCoordinates_ == null) {
          startCoordinates_ = new global::Google.Type.LatLng();
        }
        StartCoordinates.MergeFrom(other.StartCoordinates);
      }
      if (other.travelDuration_ != null) {
        if (travelDuration_ == null) {
          travelDuration_ = new global::Google.Protobuf.WellKnownTypes.Duration();
        }
        TravelDuration.MergeFrom(other.TravelDuration);
      }
      if (other.AllowImpreciseAddresses != false) {
        AllowImpreciseAddresses = other.AllowImpreciseAddresses;
      }
      switch (other.TrafficOptionCase) {
        case TrafficOptionOneofCase.RoadTraffic:
          RoadTraffic = other.RoadTraffic;
          break;
        case TrafficOptionOneofCase.DepartureTime:
          if (DepartureTime == null) {
            DepartureTime = new global::Google.Type.TimeOfDay();
          }
          DepartureTime.MergeFrom(other.DepartureTime);
          break;
      }

      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            commuteMethod_ = (global::Google.Cloud.Talent.V4Beta1.CommuteFilter.Types.CommuteMethod) input.ReadEnum();
            break;
          }
          case 18: {
            if (startCoordinates_ == null) {
              startCoordinates_ = new global::Google.Type.LatLng();
            }
            input.ReadMessage(startCoordinates_);
            break;
          }
          case 26: {
            if (travelDuration_ == null) {
              travelDuration_ = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            input.ReadMessage(travelDuration_);
            break;
          }
          case 32: {
            AllowImpreciseAddresses = input.ReadBool();
            break;
          }
          case 40: {
            trafficOption_ = input.ReadEnum();
            trafficOptionCase_ = TrafficOptionOneofCase.RoadTraffic;
            break;
          }
          case 50: {
            global::Google.Type.TimeOfDay subBuilder = new global::Google.Type.TimeOfDay();
            if (trafficOptionCase_ == TrafficOptionOneofCase.DepartureTime) {
              subBuilder.MergeFrom(DepartureTime);
            }
            input.ReadMessage(subBuilder);
            DepartureTime = subBuilder;
            break;
          }
        }
      }
    }

    #region Nested types
    /// <summary>Container for nested types declared in the CommuteFilter message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      /// <summary>
      /// Method for commute.
      /// </summary>
      public enum CommuteMethod {
        /// <summary>
        /// Commute method isn't specified.
        /// </summary>
        [pbr::OriginalName("COMMUTE_METHOD_UNSPECIFIED")] Unspecified = 0,
        /// <summary>
        /// Commute time is calculated based on driving time.
        /// </summary>
        [pbr::OriginalName("DRIVING")] Driving = 1,
        /// <summary>
        /// Commute time is calculated based on public transit including bus, metro,
        /// subway, etc.
        /// </summary>
        [pbr::OriginalName("TRANSIT")] Transit = 2,
        /// <summary>
        /// Commute time is calculated based on walking time.
        /// </summary>
        [pbr::OriginalName("WALKING")] Walking = 3,
        /// <summary>
        /// Commute time is calculated based on biking time.
        /// </summary>
        [pbr::OriginalName("BICYCLING")] Bicycling = 4,
        /// <summary>
        /// Commute time is calculated based on public transit that is wheelchair
        /// accessible.
        /// </summary>
        [pbr::OriginalName("TRANSIT_ACCESSIBLE")] TransitAccessible = 5,
      }

      /// <summary>
      /// The traffic density to use when calculating commute time.
      /// </summary>
      public enum RoadTraffic {
        /// <summary>
        /// Road traffic situation isn't specified.
        /// </summary>
        [pbr::OriginalName("ROAD_TRAFFIC_UNSPECIFIED")] Unspecified = 0,
        /// <summary>
        /// Optimal commute time without considering any traffic impact.
        /// </summary>
        [pbr::OriginalName("TRAFFIC_FREE")] TrafficFree = 1,
        /// <summary>
        /// Commute time calculation takes in account the peak traffic impact.
        /// </summary>
        [pbr::OriginalName("BUSY_HOUR")] BusyHour = 2,
      }

    }
    #endregion

  }

  /// <summary>
  /// Input only.
  ///
  /// Job title of the search.
  /// </summary>
  public sealed partial class JobTitleFilter : pb::IMessage<JobTitleFilter> {
    private static readonly pb::MessageParser<JobTitleFilter> _parser = new pb::MessageParser<JobTitleFilter>(() => new JobTitleFilter());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<JobTitleFilter> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Cloud.Talent.V4Beta1.FiltersReflection.Descriptor.MessageTypes[5]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public JobTitleFilter() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public JobTitleFilter(JobTitleFilter other) : this() {
      jobTitle_ = other.jobTitle_;
      negated_ = other.negated_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public JobTitleFilter Clone() {
      return new JobTitleFilter(this);
    }

    /// <summary>Field number for the "job_title" field.</summary>
    public const int JobTitleFieldNumber = 1;
    private string jobTitle_ = "";
    /// <summary>
    /// Required.
    ///
    /// The job title, for example, "Software engineer", or "Product manager".
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string JobTitle {
      get { return jobTitle_; }
      set {
        jobTitle_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "negated" field.</summary>
    public const int NegatedFieldNumber = 2;
    private bool negated_;
    /// <summary>
    /// Optional.
    ///
    /// Whether to apply negation to the filter so profiles matching the filter
    /// are excluded.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Negated {
      get { return negated_; }
      set {
        negated_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as JobTitleFilter);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(JobTitleFilter other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (JobTitle != other.JobTitle) return false;
      if (Negated != other.Negated) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (JobTitle.Length != 0) hash ^= JobTitle.GetHashCode();
      if (Negated != false) hash ^= Negated.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (JobTitle.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(JobTitle);
      }
      if (Negated != false) {
        output.WriteRawTag(16);
        output.WriteBool(Negated);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (JobTitle.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(JobTitle);
      }
      if (Negated != false) {
        size += 1 + 1;
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(JobTitleFilter other) {
      if (other == null) {
        return;
      }
      if (other.JobTitle.Length != 0) {
        JobTitle = other.JobTitle;
      }
      if (other.Negated != false) {
        Negated = other.Negated;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            JobTitle = input.ReadString();
            break;
          }
          case 16: {
            Negated = input.ReadBool();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// Input only.
  ///
  /// Skill filter of the search.
  /// </summary>
  public sealed partial class SkillFilter : pb::IMessage<SkillFilter> {
    private static readonly pb::MessageParser<SkillFilter> _parser = new pb::MessageParser<SkillFilter>(() => new SkillFilter());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<SkillFilter> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Cloud.Talent.V4Beta1.FiltersReflection.Descriptor.MessageTypes[6]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public SkillFilter() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public SkillFilter(SkillFilter other) : this() {
      skill_ = other.skill_;
      negated_ = other.negated_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public SkillFilter Clone() {
      return new SkillFilter(this);
    }

    /// <summary>Field number for the "skill" field.</summary>
    public const int SkillFieldNumber = 1;
    private string skill_ = "";
    /// <summary>
    /// Required.
    ///
    /// The skill name. For example, "java", "j2ee", etc.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Skill {
      get { return skill_; }
      set {
        skill_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "negated" field.</summary>
    public const int NegatedFieldNumber = 2;
    private bool negated_;
    /// <summary>
    /// Optional.
    ///
    /// Whether to apply negation to the filter so profiles matching the filter
    /// are excluded.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Negated {
      get { return negated_; }
      set {
        negated_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as SkillFilter);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(SkillFilter other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Skill != other.Skill) return false;
      if (Negated != other.Negated) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Skill.Length != 0) hash ^= Skill.GetHashCode();
      if (Negated != false) hash ^= Negated.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (Skill.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Skill);
      }
      if (Negated != false) {
        output.WriteRawTag(16);
        output.WriteBool(Negated);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Skill.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Skill);
      }
      if (Negated != false) {
        size += 1 + 1;
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(SkillFilter other) {
      if (other == null) {
        return;
      }
      if (other.Skill.Length != 0) {
        Skill = other.Skill;
      }
      if (other.Negated != false) {
        Negated = other.Negated;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Skill = input.ReadString();
            break;
          }
          case 16: {
            Negated = input.ReadBool();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// Input only.
  ///
  /// Employer filter of the search.
  /// </summary>
  public sealed partial class EmployerFilter : pb::IMessage<EmployerFilter> {
    private static readonly pb::MessageParser<EmployerFilter> _parser = new pb::MessageParser<EmployerFilter>(() => new EmployerFilter());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<EmployerFilter> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Cloud.Talent.V4Beta1.FiltersReflection.Descriptor.MessageTypes[7]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public EmployerFilter() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public EmployerFilter(EmployerFilter other) : this() {
      employer_ = other.employer_;
      mode_ = other.mode_;
      negated_ = other.negated_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public EmployerFilter Clone() {
      return new EmployerFilter(this);
    }

    /// <summary>Field number for the "employer" field.</summary>
    public const int EmployerFieldNumber = 1;
    private string employer_ = "";
    /// <summary>
    /// Required.
    ///
    /// The name of the employer, for example "Google", "Alphabet".
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Employer {
      get { return employer_; }
      set {
        employer_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "mode" field.</summary>
    public const int ModeFieldNumber = 2;
    private global::Google.Cloud.Talent.V4Beta1.EmployerFilter.Types.EmployerFilterMode mode_ = 0;
    /// <summary>
    /// Optional.
    ///
    /// Define set of [EmploymentRecord][google.cloud.talent.v4beta1.EmploymentRecord]s to search against.
    ///
    /// Defaults to [EmployerFilterMode.ALL_EMPLOYMENT_RECORDS][google.cloud.talent.v4beta1.EmployerFilter.EmployerFilterMode.ALL_EMPLOYMENT_RECORDS].
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Cloud.Talent.V4Beta1.EmployerFilter.Types.EmployerFilterMode Mode {
      get { return mode_; }
      set {
        mode_ = value;
      }
    }

    /// <summary>Field number for the "negated" field.</summary>
    public const int NegatedFieldNumber = 3;
    private bool negated_;
    /// <summary>
    /// Optional.
    ///
    /// Whether to apply negation to the filter so profiles matching the filter
    /// is excluded.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Negated {
      get { return negated_; }
      set {
        negated_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as EmployerFilter);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(EmployerFilter other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Employer != other.Employer) return false;
      if (Mode != other.Mode) return false;
      if (Negated != other.Negated) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Employer.Length != 0) hash ^= Employer.GetHashCode();
      if (Mode != 0) hash ^= Mode.GetHashCode();
      if (Negated != false) hash ^= Negated.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (Employer.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Employer);
      }
      if (Mode != 0) {
        output.WriteRawTag(16);
        output.WriteEnum((int) Mode);
      }
      if (Negated != false) {
        output.WriteRawTag(24);
        output.WriteBool(Negated);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Employer.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Employer);
      }
      if (Mode != 0) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Mode);
      }
      if (Negated != false) {
        size += 1 + 1;
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(EmployerFilter other) {
      if (other == null) {
        return;
      }
      if (other.Employer.Length != 0) {
        Employer = other.Employer;
      }
      if (other.Mode != 0) {
        Mode = other.Mode;
      }
      if (other.Negated != false) {
        Negated = other.Negated;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Employer = input.ReadString();
            break;
          }
          case 16: {
            mode_ = (global::Google.Cloud.Talent.V4Beta1.EmployerFilter.Types.EmployerFilterMode) input.ReadEnum();
            break;
          }
          case 24: {
            Negated = input.ReadBool();
            break;
          }
        }
      }
    }

    #region Nested types
    /// <summary>Container for nested types declared in the EmployerFilter message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      /// <summary>
      /// Enum indicating which set of [Profile.employment_records][google.cloud.talent.v4beta1.Profile.employment_records] to search
      /// against.
      /// </summary>
      public enum EmployerFilterMode {
        /// <summary>
        /// Default value.
        /// </summary>
        [pbr::OriginalName("EMPLOYER_FILTER_MODE_UNSPECIFIED")] Unspecified = 0,
        /// <summary>
        /// Apply to all employers in [Profile.employment_records][google.cloud.talent.v4beta1.Profile.employment_records].
        /// </summary>
        [pbr::OriginalName("ALL_EMPLOYMENT_RECORDS")] AllEmploymentRecords = 1,
        /// <summary>
        /// Apply only to current employer in [Profile.employment_records][google.cloud.talent.v4beta1.Profile.employment_records].
        /// </summary>
        [pbr::OriginalName("CURRENT_EMPLOYMENT_RECORDS_ONLY")] CurrentEmploymentRecordsOnly = 2,
        /// <summary>
        /// Apply only to past (not current) employers in
        /// [Profile.employment_records][google.cloud.talent.v4beta1.Profile.employment_records].
        /// </summary>
        [pbr::OriginalName("PAST_EMPLOYMENT_RECORDS_ONLY")] PastEmploymentRecordsOnly = 3,
      }

    }
    #endregion

  }

  /// <summary>
  /// Input only.
  ///
  /// Education filter of the search.
  /// </summary>
  public sealed partial class EducationFilter : pb::IMessage<EducationFilter> {
    private static readonly pb::MessageParser<EducationFilter> _parser = new pb::MessageParser<EducationFilter>(() => new EducationFilter());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<EducationFilter> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Cloud.Talent.V4Beta1.FiltersReflection.Descriptor.MessageTypes[8]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public EducationFilter() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public EducationFilter(EducationFilter other) : this() {
      school_ = other.school_;
      fieldOfStudy_ = other.fieldOfStudy_;
      degreeType_ = other.degreeType_;
      negated_ = other.negated_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public EducationFilter Clone() {
      return new EducationFilter(this);
    }

    /// <summary>Field number for the "school" field.</summary>
    public const int SchoolFieldNumber = 1;
    private string school_ = "";
    /// <summary>
    /// Optional.
    ///
    /// The school name. For example "MIT", "University of California, Berkeley".
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string School {
      get { return school_; }
      set {
        school_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "field_of_study" field.</summary>
    public const int FieldOfStudyFieldNumber = 2;
    private string fieldOfStudy_ = "";
    /// <summary>
    /// Optional.
    ///
    /// The field of study. This is to search against value provided in
    /// [Degree.fields_of_study][google.cloud.talent.v4beta1.Degree.fields_of_study].
    /// For example "Computer Science", "Mathematics".
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string FieldOfStudy {
      get { return fieldOfStudy_; }
      set {
        fieldOfStudy_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "degree_type" field.</summary>
    public const int DegreeTypeFieldNumber = 3;
    private global::Google.Cloud.Talent.V4Beta1.DegreeType degreeType_ = 0;
    /// <summary>
    /// Optional.
    ///
    /// Education degree in ISCED code. Each value in degree covers a specific
    /// level of education, without any expansion to upper nor lower levels of
    /// education degree.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Cloud.Talent.V4Beta1.DegreeType DegreeType {
      get { return degreeType_; }
      set {
        degreeType_ = value;
      }
    }

    /// <summary>Field number for the "negated" field.</summary>
    public const int NegatedFieldNumber = 6;
    private bool negated_;
    /// <summary>
    /// Optional.
    ///
    /// Whether to apply negation to the filter so profiles matching the filter
    /// is excluded.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Negated {
      get { return negated_; }
      set {
        negated_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as EducationFilter);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(EducationFilter other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (School != other.School) return false;
      if (FieldOfStudy != other.FieldOfStudy) return false;
      if (DegreeType != other.DegreeType) return false;
      if (Negated != other.Negated) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (School.Length != 0) hash ^= School.GetHashCode();
      if (FieldOfStudy.Length != 0) hash ^= FieldOfStudy.GetHashCode();
      if (DegreeType != 0) hash ^= DegreeType.GetHashCode();
      if (Negated != false) hash ^= Negated.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (School.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(School);
      }
      if (FieldOfStudy.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(FieldOfStudy);
      }
      if (DegreeType != 0) {
        output.WriteRawTag(24);
        output.WriteEnum((int) DegreeType);
      }
      if (Negated != false) {
        output.WriteRawTag(48);
        output.WriteBool(Negated);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (School.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(School);
      }
      if (FieldOfStudy.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(FieldOfStudy);
      }
      if (DegreeType != 0) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) DegreeType);
      }
      if (Negated != false) {
        size += 1 + 1;
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(EducationFilter other) {
      if (other == null) {
        return;
      }
      if (other.School.Length != 0) {
        School = other.School;
      }
      if (other.FieldOfStudy.Length != 0) {
        FieldOfStudy = other.FieldOfStudy;
      }
      if (other.DegreeType != 0) {
        DegreeType = other.DegreeType;
      }
      if (other.Negated != false) {
        Negated = other.Negated;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            School = input.ReadString();
            break;
          }
          case 18: {
            FieldOfStudy = input.ReadString();
            break;
          }
          case 24: {
            degreeType_ = (global::Google.Cloud.Talent.V4Beta1.DegreeType) input.ReadEnum();
            break;
          }
          case 48: {
            Negated = input.ReadBool();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// Input only.
  ///
  /// Work experience filter.
  ///
  /// This filter is used to search for profiles with working experience length
  /// between [min_experience][google.cloud.talent.v4beta1.WorkExperienceFilter.min_experience] and [max_experience][google.cloud.talent.v4beta1.WorkExperienceFilter.max_experience].
  /// </summary>
  public sealed partial class WorkExperienceFilter : pb::IMessage<WorkExperienceFilter> {
    private static readonly pb::MessageParser<WorkExperienceFilter> _parser = new pb::MessageParser<WorkExperienceFilter>(() => new WorkExperienceFilter());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<WorkExperienceFilter> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Cloud.Talent.V4Beta1.FiltersReflection.Descriptor.MessageTypes[9]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public WorkExperienceFilter() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public WorkExperienceFilter(WorkExperienceFilter other) : this() {
      minExperience_ = other.minExperience_ != null ? other.minExperience_.Clone() : null;
      maxExperience_ = other.maxExperience_ != null ? other.maxExperience_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public WorkExperienceFilter Clone() {
      return new WorkExperienceFilter(this);
    }

    /// <summary>Field number for the "min_experience" field.</summary>
    public const int MinExperienceFieldNumber = 1;
    private global::Google.Protobuf.WellKnownTypes.Duration minExperience_;
    /// <summary>
    /// Optional.
    ///
    /// The minimum duration of the work experience (inclusive).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Protobuf.WellKnownTypes.Duration MinExperience {
      get { return minExperience_; }
      set {
        minExperience_ = value;
      }
    }

    /// <summary>Field number for the "max_experience" field.</summary>
    public const int MaxExperienceFieldNumber = 2;
    private global::Google.Protobuf.WellKnownTypes.Duration maxExperience_;
    /// <summary>
    /// Optional.
    ///
    /// The maximum duration of the work experience (exclusive).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Protobuf.WellKnownTypes.Duration MaxExperience {
      get { return maxExperience_; }
      set {
        maxExperience_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as WorkExperienceFilter);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(WorkExperienceFilter other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(MinExperience, other.MinExperience)) return false;
      if (!object.Equals(MaxExperience, other.MaxExperience)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (minExperience_ != null) hash ^= MinExperience.GetHashCode();
      if (maxExperience_ != null) hash ^= MaxExperience.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (minExperience_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(MinExperience);
      }
      if (maxExperience_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(MaxExperience);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (minExperience_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(MinExperience);
      }
      if (maxExperience_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(MaxExperience);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(WorkExperienceFilter other) {
      if (other == null) {
        return;
      }
      if (other.minExperience_ != null) {
        if (minExperience_ == null) {
          minExperience_ = new global::Google.Protobuf.WellKnownTypes.Duration();
        }
        MinExperience.MergeFrom(other.MinExperience);
      }
      if (other.maxExperience_ != null) {
        if (maxExperience_ == null) {
          maxExperience_ = new global::Google.Protobuf.WellKnownTypes.Duration();
        }
        MaxExperience.MergeFrom(other.MaxExperience);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (minExperience_ == null) {
              minExperience_ = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            input.ReadMessage(minExperience_);
            break;
          }
          case 18: {
            if (maxExperience_ == null) {
              maxExperience_ = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            input.ReadMessage(maxExperience_);
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// Input only.
  ///
  /// Application Date Range Filter.
  ///
  /// The API matches profiles with [JobApplication.application_date][google.cloud.talent.v4beta1.JobApplication.application_date] between
  /// start date and end date (both boundaries are inclusive). The filter is
  /// ignored if both [start_date][google.cloud.talent.v4beta1.ApplicationDateFilter.start_date] and [end_date][google.cloud.talent.v4beta1.ApplicationDateFilter.end_date] are missing.
  /// </summary>
  public sealed partial class ApplicationDateFilter : pb::IMessage<ApplicationDateFilter> {
    private static readonly pb::MessageParser<ApplicationDateFilter> _parser = new pb::MessageParser<ApplicationDateFilter>(() => new ApplicationDateFilter());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<ApplicationDateFilter> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Cloud.Talent.V4Beta1.FiltersReflection.Descriptor.MessageTypes[10]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ApplicationDateFilter() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ApplicationDateFilter(ApplicationDateFilter other) : this() {
      startDate_ = other.startDate_ != null ? other.startDate_.Clone() : null;
      endDate_ = other.endDate_ != null ? other.endDate_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ApplicationDateFilter Clone() {
      return new ApplicationDateFilter(this);
    }

    /// <summary>Field number for the "start_date" field.</summary>
    public const int StartDateFieldNumber = 1;
    private global::Google.Type.Date startDate_;
    /// <summary>
    /// Optional.
    ///
    /// Start date. If it's missing, The API matches profiles with application date
    /// not after the end date.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Type.Date StartDate {
      get { return startDate_; }
      set {
        startDate_ = value;
      }
    }

    /// <summary>Field number for the "end_date" field.</summary>
    public const int EndDateFieldNumber = 2;
    private global::Google.Type.Date endDate_;
    /// <summary>
    /// Optional.
    ///
    /// End date. If it's missing, The API matches profiles with application date
    /// not before the start date.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Type.Date EndDate {
      get { return endDate_; }
      set {
        endDate_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as ApplicationDateFilter);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(ApplicationDateFilter other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(StartDate, other.StartDate)) return false;
      if (!object.Equals(EndDate, other.EndDate)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (startDate_ != null) hash ^= StartDate.GetHashCode();
      if (endDate_ != null) hash ^= EndDate.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (startDate_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(StartDate);
      }
      if (endDate_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(EndDate);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (startDate_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(StartDate);
      }
      if (endDate_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(EndDate);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(ApplicationDateFilter other) {
      if (other == null) {
        return;
      }
      if (other.startDate_ != null) {
        if (startDate_ == null) {
          startDate_ = new global::Google.Type.Date();
        }
        StartDate.MergeFrom(other.StartDate);
      }
      if (other.endDate_ != null) {
        if (endDate_ == null) {
          endDate_ = new global::Google.Type.Date();
        }
        EndDate.MergeFrom(other.EndDate);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (startDate_ == null) {
              startDate_ = new global::Google.Type.Date();
            }
            input.ReadMessage(startDate_);
            break;
          }
          case 18: {
            if (endDate_ == null) {
              endDate_ = new global::Google.Type.Date();
            }
            input.ReadMessage(endDate_);
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// Input only.
  ///
  /// Outcome Reason Filter.
  /// </summary>
  public sealed partial class ApplicationOutcomeReasonFilter : pb::IMessage<ApplicationOutcomeReasonFilter> {
    private static readonly pb::MessageParser<ApplicationOutcomeReasonFilter> _parser = new pb::MessageParser<ApplicationOutcomeReasonFilter>(() => new ApplicationOutcomeReasonFilter());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<ApplicationOutcomeReasonFilter> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Cloud.Talent.V4Beta1.FiltersReflection.Descriptor.MessageTypes[11]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ApplicationOutcomeReasonFilter() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ApplicationOutcomeReasonFilter(ApplicationOutcomeReasonFilter other) : this() {
      outcomeReason_ = other.outcomeReason_;
      negated_ = other.negated_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ApplicationOutcomeReasonFilter Clone() {
      return new ApplicationOutcomeReasonFilter(this);
    }

    /// <summary>Field number for the "outcome_reason" field.</summary>
    public const int OutcomeReasonFieldNumber = 1;
    private string outcomeReason_ = "";
    /// <summary>
    /// Required.
    ///
    /// User entered or selected outcome reason. The API does an exact match on the
    /// [JobApplication.outcome_reason][google.cloud.talent.v4beta1.JobApplication.outcome_reason] in profiles.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string OutcomeReason {
      get { return outcomeReason_; }
      set {
        outcomeReason_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "negated" field.</summary>
    public const int NegatedFieldNumber = 2;
    private bool negated_;
    /// <summary>
    /// Optional.
    ///
    /// If true, The API excludes all candidates with any
    /// [JobApplication.outcome_reason][google.cloud.talent.v4beta1.JobApplication.outcome_reason] matching the outcome reason specified in
    /// the filter.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Negated {
      get { return negated_; }
      set {
        negated_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as ApplicationOutcomeReasonFilter);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(ApplicationOutcomeReasonFilter other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (OutcomeReason != other.OutcomeReason) return false;
      if (Negated != other.Negated) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (OutcomeReason.Length != 0) hash ^= OutcomeReason.GetHashCode();
      if (Negated != false) hash ^= Negated.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (OutcomeReason.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(OutcomeReason);
      }
      if (Negated != false) {
        output.WriteRawTag(16);
        output.WriteBool(Negated);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (OutcomeReason.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(OutcomeReason);
      }
      if (Negated != false) {
        size += 1 + 1;
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(ApplicationOutcomeReasonFilter other) {
      if (other == null) {
        return;
      }
      if (other.OutcomeReason.Length != 0) {
        OutcomeReason = other.OutcomeReason;
      }
      if (other.Negated != false) {
        Negated = other.Negated;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            OutcomeReason = input.ReadString();
            break;
          }
          case 16: {
            Negated = input.ReadBool();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// Input only.
  ///
  /// Filter on Last Stage of Application.
  /// </summary>
  public sealed partial class ApplicationLastStageFilter : pb::IMessage<ApplicationLastStageFilter> {
    private static readonly pb::MessageParser<ApplicationLastStageFilter> _parser = new pb::MessageParser<ApplicationLastStageFilter>(() => new ApplicationLastStageFilter());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<ApplicationLastStageFilter> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Cloud.Talent.V4Beta1.FiltersReflection.Descriptor.MessageTypes[12]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ApplicationLastStageFilter() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ApplicationLastStageFilter(ApplicationLastStageFilter other) : this() {
      lastStage_ = other.lastStage_;
      negated_ = other.negated_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ApplicationLastStageFilter Clone() {
      return new ApplicationLastStageFilter(this);
    }

    /// <summary>Field number for the "last_stage" field.</summary>
    public const int LastStageFieldNumber = 1;
    private string lastStage_ = "";
    /// <summary>
    /// Required.
    ///
    /// User entered or selected last stage the candidate reached in the
    /// application. The API does an exact match on the
    /// [JobApplication.last_stage][google.cloud.talent.v4beta1.JobApplication.last_stage] in profiles.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string LastStage {
      get { return lastStage_; }
      set {
        lastStage_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "negated" field.</summary>
    public const int NegatedFieldNumber = 2;
    private bool negated_;
    /// <summary>
    /// Optional.
    /// If true, The API excludes all candidates with any
    /// [JobApplication.last_stage][google.cloud.talent.v4beta1.JobApplication.last_stage] matching the last stage specified in the
    /// filter.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Negated {
      get { return negated_; }
      set {
        negated_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as ApplicationLastStageFilter);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(ApplicationLastStageFilter other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (LastStage != other.LastStage) return false;
      if (Negated != other.Negated) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (LastStage.Length != 0) hash ^= LastStage.GetHashCode();
      if (Negated != false) hash ^= Negated.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (LastStage.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(LastStage);
      }
      if (Negated != false) {
        output.WriteRawTag(16);
        output.WriteBool(Negated);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (LastStage.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(LastStage);
      }
      if (Negated != false) {
        size += 1 + 1;
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(ApplicationLastStageFilter other) {
      if (other == null) {
        return;
      }
      if (other.LastStage.Length != 0) {
        LastStage = other.LastStage;
      }
      if (other.Negated != false) {
        Negated = other.Negated;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            LastStage = input.ReadString();
            break;
          }
          case 16: {
            Negated = input.ReadBool();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// Input only.
  ///
  /// Filter on the job information of Application.
  /// </summary>
  public sealed partial class ApplicationJobFilter : pb::IMessage<ApplicationJobFilter> {
    private static readonly pb::MessageParser<ApplicationJobFilter> _parser = new pb::MessageParser<ApplicationJobFilter>(() => new ApplicationJobFilter());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<ApplicationJobFilter> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Cloud.Talent.V4Beta1.FiltersReflection.Descriptor.MessageTypes[13]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ApplicationJobFilter() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ApplicationJobFilter(ApplicationJobFilter other) : this() {
      jobName_ = other.jobName_;
      jobRequisitionId_ = other.jobRequisitionId_;
      jobTitle_ = other.jobTitle_;
      negated_ = other.negated_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ApplicationJobFilter Clone() {
      return new ApplicationJobFilter(this);
    }

    /// <summary>Field number for the "job_name" field.</summary>
    public const int JobNameFieldNumber = 1;
    private string jobName_ = "";
    /// <summary>
    /// Optional.
    ///
    /// The job resource name in the application. The API does an exact match on
    /// the [Job.name][google.cloud.talent.v4beta1.Job.name] of [JobApplication.job][google.cloud.talent.v4beta1.JobApplication.job] in profiles.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string JobName {
      get { return jobName_; }
      set {
        jobName_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "job_requisition_id" field.</summary>
    public const int JobRequisitionIdFieldNumber = 2;
    private string jobRequisitionId_ = "";
    /// <summary>
    /// Optional.
    ///
    /// The job requisition id in the application. The API does an exact match on
    /// the [Job.requisistion_id][] of [JobApplication.job][google.cloud.talent.v4beta1.JobApplication.job] in profiles.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string JobRequisitionId {
      get { return jobRequisitionId_; }
      set {
        jobRequisitionId_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "job_title" field.</summary>
    public const int JobTitleFieldNumber = 3;
    private string jobTitle_ = "";
    /// <summary>
    /// Optional.
    ///
    /// The job title in the application. The API does an exact match on the
    /// [Job.title][google.cloud.talent.v4beta1.Job.title] of [JobApplication.job][google.cloud.talent.v4beta1.JobApplication.job] in profiles.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string JobTitle {
      get { return jobTitle_; }
      set {
        jobTitle_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "negated" field.</summary>
    public const int NegatedFieldNumber = 4;
    private bool negated_;
    /// <summary>
    /// Optional.
    ///
    /// If true, the API excludes all profiles with any [JobApplication.job][google.cloud.talent.v4beta1.JobApplication.job]
    /// matching the filters.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Negated {
      get { return negated_; }
      set {
        negated_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as ApplicationJobFilter);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(ApplicationJobFilter other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (JobName != other.JobName) return false;
      if (JobRequisitionId != other.JobRequisitionId) return false;
      if (JobTitle != other.JobTitle) return false;
      if (Negated != other.Negated) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (JobName.Length != 0) hash ^= JobName.GetHashCode();
      if (JobRequisitionId.Length != 0) hash ^= JobRequisitionId.GetHashCode();
      if (JobTitle.Length != 0) hash ^= JobTitle.GetHashCode();
      if (Negated != false) hash ^= Negated.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (JobName.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(JobName);
      }
      if (JobRequisitionId.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(JobRequisitionId);
      }
      if (JobTitle.Length != 0) {
        output.WriteRawTag(26);
        output.WriteString(JobTitle);
      }
      if (Negated != false) {
        output.WriteRawTag(32);
        output.WriteBool(Negated);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (JobName.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(JobName);
      }
      if (JobRequisitionId.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(JobRequisitionId);
      }
      if (JobTitle.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(JobTitle);
      }
      if (Negated != false) {
        size += 1 + 1;
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(ApplicationJobFilter other) {
      if (other == null) {
        return;
      }
      if (other.JobName.Length != 0) {
        JobName = other.JobName;
      }
      if (other.JobRequisitionId.Length != 0) {
        JobRequisitionId = other.JobRequisitionId;
      }
      if (other.JobTitle.Length != 0) {
        JobTitle = other.JobTitle;
      }
      if (other.Negated != false) {
        Negated = other.Negated;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            JobName = input.ReadString();
            break;
          }
          case 18: {
            JobRequisitionId = input.ReadString();
            break;
          }
          case 26: {
            JobTitle = input.ReadString();
            break;
          }
          case 32: {
            Negated = input.ReadBool();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// Input only.
  ///
  /// Filter on status of Application.
  /// </summary>
  public sealed partial class ApplicationStatusFilter : pb::IMessage<ApplicationStatusFilter> {
    private static readonly pb::MessageParser<ApplicationStatusFilter> _parser = new pb::MessageParser<ApplicationStatusFilter>(() => new ApplicationStatusFilter());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<ApplicationStatusFilter> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Cloud.Talent.V4Beta1.FiltersReflection.Descriptor.MessageTypes[14]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ApplicationStatusFilter() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ApplicationStatusFilter(ApplicationStatusFilter other) : this() {
      applicationStatus_ = other.applicationStatus_;
      negated_ = other.negated_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ApplicationStatusFilter Clone() {
      return new ApplicationStatusFilter(this);
    }

    /// <summary>Field number for the "application_status" field.</summary>
    public const int ApplicationStatusFieldNumber = 1;
    private global::Google.Cloud.Talent.V4Beta1.JobApplication.Types.ApplicationStatus applicationStatus_ = 0;
    /// <summary>
    /// Required.
    ///
    /// User entered or selected application status. The API does an exact match
    /// between the application status specified in this filter and the
    /// [JobApplication.status][] in profiles.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Cloud.Talent.V4Beta1.JobApplication.Types.ApplicationStatus ApplicationStatus {
      get { return applicationStatus_; }
      set {
        applicationStatus_ = value;
      }
    }

    /// <summary>Field number for the "negated" field.</summary>
    public const int NegatedFieldNumber = 2;
    private bool negated_;
    /// <summary>
    /// Optional.
    ///
    /// If true, The API excludes all candidates with any [JobApplication.status][]
    /// matching the status specified in the filter.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Negated {
      get { return negated_; }
      set {
        negated_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as ApplicationStatusFilter);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(ApplicationStatusFilter other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (ApplicationStatus != other.ApplicationStatus) return false;
      if (Negated != other.Negated) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (ApplicationStatus != 0) hash ^= ApplicationStatus.GetHashCode();
      if (Negated != false) hash ^= Negated.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (ApplicationStatus != 0) {
        output.WriteRawTag(8);
        output.WriteEnum((int) ApplicationStatus);
      }
      if (Negated != false) {
        output.WriteRawTag(16);
        output.WriteBool(Negated);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (ApplicationStatus != 0) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) ApplicationStatus);
      }
      if (Negated != false) {
        size += 1 + 1;
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(ApplicationStatusFilter other) {
      if (other == null) {
        return;
      }
      if (other.ApplicationStatus != 0) {
        ApplicationStatus = other.ApplicationStatus;
      }
      if (other.Negated != false) {
        Negated = other.Negated;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            applicationStatus_ = (global::Google.Cloud.Talent.V4Beta1.JobApplication.Types.ApplicationStatus) input.ReadEnum();
            break;
          }
          case 16: {
            Negated = input.ReadBool();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// Input only.
  ///
  /// Filter on create timestamp or update timestamp of profiles.
  /// </summary>
  public sealed partial class TimeFilter : pb::IMessage<TimeFilter> {
    private static readonly pb::MessageParser<TimeFilter> _parser = new pb::MessageParser<TimeFilter>(() => new TimeFilter());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<TimeFilter> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Cloud.Talent.V4Beta1.FiltersReflection.Descriptor.MessageTypes[15]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TimeFilter() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TimeFilter(TimeFilter other) : this() {
      startTime_ = other.startTime_ != null ? other.startTime_.Clone() : null;
      endTime_ = other.endTime_ != null ? other.endTime_.Clone() : null;
      timeField_ = other.timeField_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TimeFilter Clone() {
      return new TimeFilter(this);
    }

    /// <summary>Field number for the "start_time" field.</summary>
    public const int StartTimeFieldNumber = 1;
    private global::Google.Protobuf.WellKnownTypes.Timestamp startTime_;
    /// <summary>
    /// Optional.
    ///
    /// Start timestamp, matching profiles with the start time. If this field
    /// missing, The API matches profiles with create / update timestamp before the
    /// end timestamp.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Protobuf.WellKnownTypes.Timestamp StartTime {
      get { return startTime_; }
      set {
        startTime_ = value;
      }
    }

    /// <summary>Field number for the "end_time" field.</summary>
    public const int EndTimeFieldNumber = 2;
    private global::Google.Protobuf.WellKnownTypes.Timestamp endTime_;
    /// <summary>
    /// Optional.
    ///
    /// End timestamp, matching profiles with the end time. If this field
    /// missing, The API matches profiles with create / update timestamp after the
    /// start timestamp.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Protobuf.WellKnownTypes.Timestamp EndTime {
      get { return endTime_; }
      set {
        endTime_ = value;
      }
    }

    /// <summary>Field number for the "time_field" field.</summary>
    public const int TimeFieldFieldNumber = 3;
    private global::Google.Cloud.Talent.V4Beta1.TimeFilter.Types.TimeField timeField_ = 0;
    /// <summary>
    /// Optional.
    ///
    /// Specifies which time field to filter profiles.
    ///
    /// Defaults to [TimeField.CREATE_TIME][google.cloud.talent.v4beta1.TimeFilter.TimeField.CREATE_TIME].
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Cloud.Talent.V4Beta1.TimeFilter.Types.TimeField TimeField {
      get { return timeField_; }
      set {
        timeField_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as TimeFilter);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(TimeFilter other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(StartTime, other.StartTime)) return false;
      if (!object.Equals(EndTime, other.EndTime)) return false;
      if (TimeField != other.TimeField) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (startTime_ != null) hash ^= StartTime.GetHashCode();
      if (endTime_ != null) hash ^= EndTime.GetHashCode();
      if (TimeField != 0) hash ^= TimeField.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (startTime_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(StartTime);
      }
      if (endTime_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(EndTime);
      }
      if (TimeField != 0) {
        output.WriteRawTag(24);
        output.WriteEnum((int) TimeField);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (startTime_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(StartTime);
      }
      if (endTime_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(EndTime);
      }
      if (TimeField != 0) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) TimeField);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(TimeFilter other) {
      if (other == null) {
        return;
      }
      if (other.startTime_ != null) {
        if (startTime_ == null) {
          startTime_ = new global::Google.Protobuf.WellKnownTypes.Timestamp();
        }
        StartTime.MergeFrom(other.StartTime);
      }
      if (other.endTime_ != null) {
        if (endTime_ == null) {
          endTime_ = new global::Google.Protobuf.WellKnownTypes.Timestamp();
        }
        EndTime.MergeFrom(other.EndTime);
      }
      if (other.TimeField != 0) {
        TimeField = other.TimeField;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (startTime_ == null) {
              startTime_ = new global::Google.Protobuf.WellKnownTypes.Timestamp();
            }
            input.ReadMessage(startTime_);
            break;
          }
          case 18: {
            if (endTime_ == null) {
              endTime_ = new global::Google.Protobuf.WellKnownTypes.Timestamp();
            }
            input.ReadMessage(endTime_);
            break;
          }
          case 24: {
            timeField_ = (global::Google.Cloud.Talent.V4Beta1.TimeFilter.Types.TimeField) input.ReadEnum();
            break;
          }
        }
      }
    }

    #region Nested types
    /// <summary>Container for nested types declared in the TimeFilter message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      /// <summary>
      /// Time fields can be used in TimeFilter.
      /// </summary>
      public enum TimeField {
        /// <summary>
        /// Default value.
        /// </summary>
        [pbr::OriginalName("TIME_FIELD_UNSPECIFIED")] Unspecified = 0,
        /// <summary>
        /// Earliest profile create time.
        /// </summary>
        [pbr::OriginalName("CREATE_TIME")] CreateTime = 1,
        /// <summary>
        /// Latest profile update time.
        /// </summary>
        [pbr::OriginalName("UPDATE_TIME")] UpdateTime = 2,
      }

    }
    #endregion

  }

  #endregion

}

#endregion Designer generated code
