// Copyright 2017 Google Inc. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Xml.Linq;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Formatting;
using Microsoft.CodeAnalysis.Text;

// ReSharper disable PossibleNullReferenceException

namespace Google.Cloud.Tools.DataGenerator
{
    /// <summary>
    /// This program takes in a path where a config file and source files reside.
    /// It loads the config file and copies all source methods to a target class, making some transformations
    /// and cleanups along the way.
    /// The created methods will all have an expression body that delegates to as assumed method that returns
    /// the source type (Get{SourceType}).
    /// Extra config can be supplied to both
    /// a) suppress generation of certain methods (for any reason)
    /// b) create additional overloads with some parameters removed (replaced in the expression body with the given
    ///    text.
    /// </summary>
    public class Program
    {
        private static Dictionary<string, string> s_parametersToExclude;
        private static HashSet<string> s_methodsExcluded;
        private static readonly AdhocWorkspace s_workspace = new AdhocWorkspace();

        private static readonly string s_regionStart =
            $@"#region Autogenerated code (DO NOT MODIFY!){Environment.NewLine}";
        private static readonly string s_regionEnd = $@"#endregion{Environment.NewLine}";

        private static readonly HashSet<string> s_generatedOverloads = new HashSet<string>();
        private static readonly Dictionary<string, string> s_empty = new Dictionary<string, string>();
        private static string s_sourcePrefix;
        private static string s_destinationPrefix;

        private static int Main(string[] args)
        {
            if (args.Length != 1)
            {
                Console.WriteLine("Arguments: <path to files>");
                return 1;
            }

            try
            {
                //Load config
                var root = XDocument.Load($"{args[0]}{Path.DirectorySeparatorChar}DataGeneratorConfig.xml").Root;
                s_sourcePrefix = root.Element("SourceFilePrefix").Value;
                s_destinationPrefix = root.Element("DestinationFilePrefix").Value;
                s_methodsExcluded = new HashSet<string>(root.Elements("ExcludedMethod").Select(x => x.Value));
                s_parametersToExclude = root.Elements("ParameterReplacement").ToDictionary(
                    x => x.Value.Split(',').ElementAt(0),
                    x => x.Value.Split(',').ElementAt(1));

                //Process each file.  We copy all public methods from source.*.cs to destination.*.cs
                //with intelligent transforms along the way.
                foreach (var file in new DirectoryInfo(args[0]).GetFiles($"{s_sourcePrefix}.*.cs"))
                {
                    Console.WriteLine($"Processing {file.Name}");
                    var destinationFile = new FileInfo(file.FullName.Replace(s_sourcePrefix, s_destinationPrefix));
                    if (!destinationFile.Exists)
                    {
                        Console.Error.WriteLine($"Unable to find file {destinationFile.FullName}.");
                        return 1;
                    }
                    ProcessFile(file, destinationFile);
                }
                return 0;
            }
            catch (Exception e)
            {
                Console.WriteLine($"Error: {e}");
                return 1;
            }
        }

        private static void ProcessFile(FileInfo file, FileInfo destinationFile)
        {
            using (var reader = file.OpenText())
            {
                var destinationText = File.ReadAllText(destinationFile.FullName);
                var regionStartIndex = destinationText.IndexOf(s_regionStart, StringComparison.Ordinal);
                var regionEndIndex = destinationText.IndexOf(s_regionEnd, StringComparison.Ordinal);
                if (regionStartIndex == -1 || regionEndIndex == -1)
                    throw new Exception($"Unable to find the autogenerated section in {destinationFile.FullName}");

                var destinationBuilder = new StringBuilder(destinationText.Remove(
                    regionStartIndex + s_regionStart.Length,
                    regionEndIndex - regionStartIndex - s_regionStart.Length));
                var textToInsert = new StringBuilder();

                var sourceText = SourceText.From(reader, (int) file.Length);
                var root = CSharpSyntaxTree.ParseText(sourceText).GetRoot();

                foreach (var sourceMethod in root.DescendantNodes().OfType<MethodDeclarationSyntax>()
                    .Where(method => !s_methodsExcluded.Contains(method.Identifier.ToString())
                                     && method.Modifiers.Any(x => x.IsKind(SyntaxKind.PublicKeyword))))
                {
                    if (CreateDestinationMethod(sourceMethod, s_empty, out string methodText))
                        textToInsert.Append(methodText);
                    //Create the extra overload, removing optional replaceable parameters.
                    if (CreateDestinationMethod(sourceMethod, s_parametersToExclude, out methodText))
                        textToInsert.Append(methodText);
                }

                //Insert the new methods.
                destinationBuilder.Insert(regionStartIndex + s_regionStart.Length, textToInsert);

                //Reformat the document.
                var newRoot = Formatter.Format(
                    CSharpSyntaxTree.ParseText(destinationBuilder.ToString()).GetRoot(), s_workspace);

                File.WriteAllText(destinationFile.FullName, newRoot.ToFullString());
            }
        }

        /// <summary>
        /// Returns true if a new destination method was created along with the full text of that new method.
        /// Returns false if the generated method has a duplicate signature with an alreadying existing method.
        /// This can happen because we create simplified additional overloads subsitituting the parameters supplied
        /// in config with calls in the expression body.
        /// </summary>
        private static bool CreateDestinationMethod(
            MethodDeclarationSyntax sourceMethod,
            Dictionary<string, string> parameterExclusions,
            out string destinationMethodText)
        {
            destinationMethodText = null;

            var newMethod = sourceMethod.WithBody(null)
                .WithParameterList(CreateParameters(sourceMethod, parameterExclusions))
                .WithSemicolonToken(SyntaxFactory.Token(SyntaxKind.None))
                .WithExpressionBody(CreateExpressionBody(sourceMethod, parameterExclusions)
                    .WithLeadingTrivia(SyntaxFactory.Whitespace($"{Environment.NewLine}            "))
                )
                .WithModifiers(SyntaxFactory.TokenList(sourceMethod.Modifiers.Where(
                    x => !x.IsKind(SyntaxKind.VirtualKeyword) && !x.IsKind(SyntaxKind.AsyncKeyword))
                ));

            //We need to remove all region declarations which can show up as leading or trailing trivia.
            var formattedMethod = (MethodDeclarationSyntax) new DocCommentFixer(parameterExclusions).Visit(
                newMethod.WithTrailingTrivia(
                        newMethod.GetTrailingTrivia().Where(x => !x.IsKind(SyntaxKind.WhitespaceTrivia))
                            .Concat(new[] {SyntaxFactory.Whitespace(Environment.NewLine)}))
                    .WithLeadingTrivia(newMethod.GetLeadingTrivia()
                        .Where(x => !x.IsKind(SyntaxKind.RegionDirectiveTrivia)
                                    && !x.IsKind(SyntaxKind.EndRegionDirectiveTrivia)))
            );

            var key = $"{formattedMethod.Identifier}.{formattedMethod.ParameterList.ToFullString()}";
            if (s_generatedOverloads.Contains(key)) return false;

            s_generatedOverloads.Add(key);
            destinationMethodText = formattedMethod.ToFullString();
            return true;
        }

        /// <summary>
        /// Creates an ArrowExpressionBody forwarding to the source type.
        /// </summary>
        private static ArrowExpressionClauseSyntax CreateExpressionBody(
            MethodDeclarationSyntax asyncMethod,
            IReadOnlyDictionary<string, string> parameterExclusions) => SyntaxFactory.ArrowExpressionClause(
            SyntaxFactory
                .ExpressionStatement(
                    SyntaxFactory.InvocationExpression(
                            SyntaxFactory.MemberAccessExpression(
                                SyntaxKind.SimpleMemberAccessExpression,
                                SyntaxFactory.InvocationExpression(
                                    SyntaxFactory.IdentifierName($"Get{s_sourcePrefix}")),
                                SyntaxFactory.IdentifierName(asyncMethod.Identifier.ToString())))
                        .WithArgumentList(
                            SyntaxFactory.ArgumentList(
                                    SyntaxFactory.SeparatedList<ArgumentSyntax>(
                                        CreateArguments(asyncMethod.ParameterList.Parameters, parameterExclusions)
                                    ))
                                .WithCloseParenToken(
                                    SyntaxFactory.Token(
                                        SyntaxFactory.TriviaList(),
                                        SyntaxKind.CloseParenToken,
                                        SyntaxFactory.TriviaList(
                                            SyntaxFactory.Trivia(
                                                SyntaxFactory.SkippedTokensTrivia()
                                                    .WithTokens(
                                                        SyntaxFactory.TokenList(
                                                            SyntaxFactory.Token(SyntaxKind.SemicolonToken))))))))
                ).Expression);

        private static ParameterListSyntax CreateParameters(MethodDeclarationSyntax asyncMethod,
            Dictionary<string, string> parameterExclusions) => SyntaxFactory.ParameterList(SyntaxFactory.SeparatedList(
            asyncMethod.ParameterList.Parameters
                .Where(p => !parameterExclusions.ContainsKey(p.Identifier.ToString()))
                .Select(
                    x => x.WithTrailingTrivia())
        ));

        /// <summary>
        /// Generates an argument list from a parameter declaration list -- substituting removed/optional parameters
        /// with their requested equivalents.
        /// </summary>
        private static IEnumerable<SyntaxNodeOrToken> CreateArguments(
            SeparatedSyntaxList<ParameterSyntax> parameterListParameters,
            IReadOnlyDictionary<string, string> parameterExclusions)
        {
            var first = true;
            foreach (var parameter in parameterListParameters.Where(x => x.IsKind(SyntaxKind.Parameter)))
            {
                if (!first)
                    yield return SyntaxFactory.Token(SyntaxKind.CommaToken);
                first = false;
                yield return parameterExclusions.TryGetValue(parameter.Identifier.ToString(),
                    out string replacementCode)
                    ? SyntaxFactory.Argument(SyntaxFactory.ParseExpression(replacementCode))
                    : SyntaxFactory.Argument(SyntaxFactory.IdentifierName(parameter.Identifier.ToString()));
            }
        }

        /// <summary>
        /// For extra generated overloads (with removed parameters), this visitor removes
        /// the parameter doccomments for those removed parameters.
        /// </summary>
        public class DocCommentFixer : CSharpSyntaxRewriter
        {
            private readonly Dictionary<string, string> _parameterExclusions;

            public DocCommentFixer(Dictionary<string, string> excludedParameters) => _parameterExclusions =
                excludedParameters;

            public override SyntaxTrivia VisitTrivia(SyntaxTrivia trivia)
            {
                if (!trivia.IsKind(SyntaxKind.SingleLineDocumentationCommentTrivia) || _parameterExclusions.Count == 0)
                    return base.VisitTrivia(trivia);

                var xmlStructure = trivia.GetStructure();
                var allNodes = xmlStructure.DescendantNodes().ToList();
                var nodesToRemove = new List<SyntaxNode>();

                foreach (var removedParams in _parameterExclusions)
                {
                    var indexOfRemovedParam = allNodes.FindIndex(x => x is XmlElementSyntax syntaxElement
                                                                      && syntaxElement.StartTag.Attributes.Any(y => y
                                                                          .ToString().Contains(
                                                                              $@"""{removedParams.Key}""")));

                    if (indexOfRemovedParam == -1) continue;
                    nodesToRemove.Add(allNodes[indexOfRemovedParam - 1]); //three slashes
                    nodesToRemove.Add(allNodes[indexOfRemovedParam]);
                }
                xmlStructure = xmlStructure.RemoveNodes(nodesToRemove, SyntaxRemoveOptions.KeepNoTrivia);
                return SyntaxFactory.ParseLeadingTrivia(xmlStructure.ToFullString()).First();
            }
        }
    }
}